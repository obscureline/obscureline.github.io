<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>IO流 | obscureline</title><meta name="author" content="obscureline"><meta name="copyright" content="obscureline"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172WebService（SOAP）与Http接口（API）的区别:soap请求是http post的一个专用版本，遵循一种特殊的xm"><meta property="og:type" content="article"><meta property="og:title" content="IO流"><meta property="og:url" content="http://obscureline.com/2023/04/14/29.IO%E6%B5%81/index.html"><meta property="og:site_name" content="obscureline"><meta property="og:description" content="123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172WebService（SOAP）与Http接口（API）的区别:soap请求是http post的一个专用版本，遵循一种特殊的xm"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.imgdb.cn/item/640ed8e3f144a010075b4567.png"><meta property="article:published_time" content="2023-04-14T15:26:11.715Z"><meta property="article:modified_time" content="2023-07-07T06:42:28.926Z"><meta property="article:author" content="obscureline"><meta property="article:tag" content="IO"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.imgdb.cn/item/640ed8e3f144a010075b4567.png"><link rel="shortcut icon" href="https://pic.imgdb.cn/item/64d5a8421ddac507ccb630dd.webp"><link rel="canonical" href="http://obscureline.com/2023/04/14/29.IO%E6%B5%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":false,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: obscureline","link":"链接: ","source":"来源: obscureline","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"IO流",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2023-07-07 14:42:28"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640daf34f144a010075844fd.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-spinner"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-archive"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://pic.imgdb.cn/item/640ed8e3f144a010075b4567.png)"><nav id="nav"><span id="blog-info"><a href="/" title="obscureline"><span class="site-name">obscureline</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-spinner"></i><span> 图库</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-archive"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">IO流</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-14T15:26:11.715Z" title="发表于 2023-04-14 23:26:11">2023-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-07T06:42:28.926Z" title="更新于 2023-07-07 14:42:28">2023-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IO/">IO</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="IO流"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">WebService（SOAP）与Http接口（API）的区别:</span><br><span class="line">soap请求是http post的一个专用版本，遵循一种特殊的<span class="type">xml</span>消息格式content-<span class="keyword">type</span>设置为: <span class="type">text</span>/<span class="type">xml</span>任何数据都可以<span class="type">xml</span>化。</span><br><span class="line">大多数对外接口会实现web service方法而不是http方法。</span><br><span class="line">httpservice通过post和<span class="keyword">get</span>得到你想要的东西，进行<span class="type">xml</span>解析，速度可能会有所降低。</span><br><span class="line">webservice就是使用soap协议得到你想要的东西，相比httpservice能处理些更加复杂的数据类型。</span><br><span class="line">http协议传输的都是字符串了，webservice则是包装成了更复杂的对象。</span><br><span class="line">webservice走http协议和<span class="number">80</span>端口。而你说的api，用的协议和端口，是根据开发人员定义的。</span><br><span class="line"></span><br><span class="line">string为啥用final修饰，是线程安全的吗？</span><br><span class="line">* string是final修饰的类，是不可变的，所以是线程安全的。</span><br><span class="line">String类不可被继承。String类的不可变性，才能使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。字符串对象在多线程环境下是线程安全的。如果String类是可变的，那么会引起很严重的安全问题。</span><br><span class="line"></span><br><span class="line">stringbuffer，string,stringbulider 区别？</span><br><span class="line">* 运行速度和线程安全</span><br><span class="line"></span><br><span class="line">synchronized和<span class="keyword">lock</span>区别？</span><br><span class="line">* Synchronized 是Java 并发编程中很重要的关键字</span><br><span class="line">Syncronized 的目的是一次只允许一个线程进入由他修饰的代码段，从而允许他们进行自我保护。Synchronized 很像生活中的锁例子，进入由Synchronized 保护的代码区首先需要获取 Synchronized 这把锁，其他线程想要执行必须进行等待。Synchronized 锁住的代码区域执行完成后需要把锁归还，也就是释放锁，这样才能够让其他线程使用。</span><br><span class="line">* <span class="keyword">Lock</span> 是 Java并发编程中很重要的一个接口，</span><br><span class="line"><span class="keyword">Lock</span>需要手动加锁和手动解锁，一般通过 <span class="keyword">lock</span>.<span class="keyword">lock</span>() 方法来进行加锁， 通过 <span class="keyword">lock</span>.unlock() 方法进行解锁。</span><br><span class="line"></span><br><span class="line">java有什么方法进入阻塞状态？</span><br><span class="line">* 线程阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪)</span><br><span class="line">sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态</span><br><span class="line">wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 <span class="keyword">notify</span>() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 <span class="keyword">notify</span>() 被调用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">notify</span>()方法、notifyAll()方法和wait()方法</span><br><span class="line">- wait()、<span class="keyword">notify</span>()和notifyAll()方法使类<span class="keyword">Object</span>中定义的方法</span><br><span class="line">- wait()</span><br><span class="line">	try&#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">- <span class="keyword">notify</span>()</span><br><span class="line">	使用某个对象的<span class="keyword">notify</span>()方法时，将从该对象的等待集合中选择一个等待的线程唤醒，唤醒的将从集合中删除。</span><br><span class="line">- notifyAll()</span><br><span class="line">	会将所有在等待集合中的线程唤醒，但由于所有的被唤醒的线程仍然要去争用synchronized锁，而synchronized锁具有排他性，最终只有一个线程获得该锁，进行执行状态，其他线程仍要继续等待。</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>加锁过程</span><br><span class="line">一种是关键字：synchronized： 是java底层支持的。</span><br><span class="line">一种是concurrent包下的<span class="keyword">lock</span>锁： 是jdk实现。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>怎么保证可见性?</span><br><span class="line"><span class="keyword">volatile</span>关键字能够保证可见性和有序性</span><br><span class="line"></span><br><span class="line">垃圾收集器有哪些？</span><br><span class="line">G1 垃圾回收器，是一种高吞吐量的垃圾回收器。</span><br><span class="line">CMS 垃圾回收器，并发标记清除垃圾回收器。</span><br><span class="line">垃圾回收算法: </span><br><span class="line">标记清除</span><br><span class="line">* 是一种先标记，后清除的算法，在第一次扫描的时候先标记出所有需要清理的内存，将所有需要回收的内存都标记过后，一次性清理掉。这种算法简单但是效率低，而且内存碎片化严重。</span><br><span class="line">复制算法</span><br><span class="line">* 把内存分成两部分，在平时使用的时候只用其中的固定一份，在当需要进行 GC 的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。</span><br><span class="line">标记整理算法</span><br><span class="line">* 标记阶段是标记清除算法一样，先标记出需要回收的部分，不过清除阶段不是直接清除，而是把存活的对象往内存的一端进行移动，然后清除剩下的部分。</span><br><span class="line">分代回收算法</span><br><span class="line">* 分代回收算法是目前使用较多的一种算法，这个不是一个新的算法，只是将内存进行的划分，不同区域的内存使用不同的算法。根据对象的存活时间将内存的划分为新生代和老年代，其中新生代包含 Eden 区和 S0，S1。在新生代中使用是复制算法，在进行对象内存分配的时候只会使用 Eden 和 S0 区，当发生 GC 的时候，会将存活的对象复制到 S1 区，然后循环往复进行复制。当某个对象在进行了 <span class="number">15</span> 次GC 后依旧存活，那这个对象就会进入老年代。老年代因为每次回收的对象都会比较少，因此使用的是标记整理算法。</span><br><span class="line"></span><br><span class="line">双亲委派好处？打破？</span><br><span class="line">如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</span><br><span class="line">如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</span><br><span class="line">如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</span><br><span class="line">-避免类的重复加载</span><br><span class="line">-保护程序安全，防止核心API被随意篡改</span><br><span class="line"></span><br><span class="line">fullgc怎么回事？</span><br><span class="line"><span class="number">1</span>、项目启动时加载了比较多或者比较大的对象，导致空间不够，频繁扩容；</span><br><span class="line"><span class="number">2</span>、初始化空间太小，不够用，所以进行频繁扩容。</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> a&gt;<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> c怎么建索引？</span><br><span class="line">排序字段进行索引的创建</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">简单说一下对SpringBoot的理解</span><br><span class="line">SpringBoot是基于 Spring 开发的一种轻量级的全新框架，不仅继承了 Spring 框架原有的优秀特性，而且还通过简化配置来进一步简化了 Spring 应用的整个搭建和开发过程。 通过 Spring Boot，可以轻松地创建独立的，基于生产级别的基于 Spring 的应用程序。</span><br><span class="line"></span><br><span class="line">项目里面用到了哪些注解</span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@RunWith</span>(SpringRunner.class) <span class="variable">@SpringBootTest</span></span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line"><span class="variable">@Autowired</span></span><br><span class="line"><span class="variable">@RestController</span><span class="operator">=</span>Controller<span class="operator">+</span>ResponseBody</span><br><span class="line"><span class="variable">@ReqeustMapping</span></span><br><span class="line"><span class="variable">@RequestParam</span> <span class="variable">@PathVariable</span><span class="variable">@RequestBody</span></span><br><span class="line"><span class="operator">*</span> <span class="variable">@RequestBody</span>主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；而最常用的使用请求体传参的无疑是POST请求了，所以使用<span class="variable">@RequestBody</span>接收数据时，一般都用POST方式进行提交。在后端的同一个接收方法里，<span class="variable">@RequestBody</span>与<span class="variable">@RequestParam</span>()可以同时使用，<span class="variable">@RequestBody</span>最多只能有一个，而<span class="variable">@RequestParam</span>()可以有多个。</span><br><span class="line"></span><br><span class="line">简单说一下项目里面的Redis缓存</span><br><span class="line">redis作为缓存的作用就是减少对数据库的访问压力，当我们访问一个数据的时候，首先我们从redis中查看是否有该数据，如果没有，则从数据库中读取，将从数据库中读取的数据存放到缓存中，下次再访问同样的数据的是，还是先判断redis中是否存在该数据，如果有，则从缓存中读取，不访问数据库</span><br><span class="line"></span><br><span class="line">JDK和JRE的区别</span><br><span class="line">JDK顾名思义是java开发工具包（JRE和开发工具）</span><br><span class="line">JRE顾名思义是java运行时环境（JVM和核心类库）</span><br><span class="line"></span><br><span class="line">说一下Java的<span class="number">8</span>种基本数据类型</span><br><span class="line">java八种基本数据类型分为四类八种，四类分别为整型、浮点型、布尔型、字符型；八种分别为byte、short、<span class="type">int</span>、long、<span class="type">float</span>、<span class="keyword">double</span>、<span class="type">boolean</span>、<span class="type">char</span>；</span><br><span class="line"></span><br><span class="line">创建线程有那哪些方式</span><br><span class="line">继承Thread类创建线程</span><br><span class="line">实现Runnable接口创建线程</span><br><span class="line"></span><br><span class="line">Session和Cookie的区别</span><br><span class="line">cookie数据保存在客户端，session数据保存在服务端。</span><br><span class="line">客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Get</span>请求和Post请求的区别</span><br><span class="line">http请求方式有<span class="keyword">get</span>、post、put、<span class="keyword">delete</span>等多种</span><br><span class="line"><span class="number">1</span>、<span class="keyword">GET</span>请求一般用去请求获取数据，</span><br><span class="line">POST一般作为发送数据到后台时使用</span><br><span class="line"><span class="number">2</span>、<span class="keyword">GET</span>请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的</span><br><span class="line">POST请求传递参数放在Request body中，不会在url中显示，比<span class="keyword">GET</span>要安全，且参数长度无限制</span><br><span class="line"><span class="number">3</span>、<span class="keyword">GET</span>请求刷新浏览器或回退时没有影响</span><br><span class="line">POST回退时会重新提交数据请求</span><br><span class="line"><span class="number">4</span>、<span class="keyword">GET</span> 请求可被缓存</span><br><span class="line">POST 请求不会被缓存</span><br><span class="line"><span class="number">5</span>、<span class="keyword">GET</span> 请求保留在浏览器历史记录中</span><br><span class="line">POST 请求不会保留在浏览器历史记录中</span><br><span class="line"><span class="number">6</span>、<span class="keyword">GET</span> 请求可被收藏为书签</span><br><span class="line">POST 不能被收藏为书签</span><br><span class="line"><span class="number">7</span>、<span class="keyword">GET</span>请求只能进行url编码（application<span class="operator">/</span>x<span class="operator">-</span>www<span class="operator">-</span>form<span class="operator">-</span>urlencoded）</span><br><span class="line">POST支持多种编码方式（application<span class="operator">/</span>x<span class="operator">-</span>www<span class="operator">-</span>form<span class="operator">-</span>urlencoded 或 multipart<span class="operator">/</span>form<span class="operator">-</span>data。为二进制数据使用多重编码。）</span><br><span class="line"><span class="number">8</span>、<span class="keyword">GET</span>请求比较常见的方式是通过url地址栏请求</span><br><span class="line">POST最常见是通过form表单发送数据请求</span><br><span class="line"></span><br><span class="line">集合List ，<span class="keyword">Set</span>，Map</span><br><span class="line">List和<span class="keyword">Set</span>是存储单列数据的集合，Map是存储键值对这样的双列数据的集合；</span><br><span class="line">List中存储的数据是有顺序的，并且值允许重复；</span><br><span class="line">Map中存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的；</span><br><span class="line"><span class="keyword">Set</span>中存储的数据是无顺序的，并且不允许重复，但元素在集合中的位置是由元素的hashcode决定，即位置是固定的（<span class="keyword">Set</span>集合是根据hashcode来进行数据存储的，所以位置是固定的，但是这个位置不是用户可以控制的，所以对于用户来说<span class="keyword">set</span>中的元素还是无序的）</span><br><span class="line">List接口有三个实现类：</span><br><span class="line"><span class="number">1.1</span> LinkedList</span><br><span class="line">基于链表实现，链表内存是散列的，增删快，查找慢；</span><br><span class="line"><span class="number">1.2</span> ArrayList</span><br><span class="line">基于数组实现，非线程安全，效率高，增删慢，查找快；</span><br><span class="line"><span class="number">1.3</span> Vector</span><br><span class="line">基于数组实现，线程安全，效率低，增删慢，查找慢；</span><br><span class="line"><span class="keyword">Set</span>接口有两个实现类：</span><br><span class="line"><span class="number">3.1</span> HashSet</span><br><span class="line">底层是由 Hash Map 实现，不允许集合中有重复的值，使用该方式时需要重写 <span class="keyword">equals</span>()和 hash Code()方法；</span><br><span class="line"><span class="number">3.2</span> LinkedHashSet</span><br><span class="line">继承于 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap</span><br><span class="line">Map接口有四个实现类：</span><br><span class="line"><span class="number">2.1</span> HashMap</span><br><span class="line">基于 hash 表的 Map 接口实现，非线程安全，高效，支持 <span class="keyword">null</span> 值和 <span class="keyword">null</span></span><br><span class="line">键；</span><br><span class="line"><span class="number">2.2</span> HashTable</span><br><span class="line">线程安全，低效，不支持 <span class="keyword">null</span> 值和 <span class="keyword">null</span> 键；</span><br><span class="line"><span class="number">2.3</span> LinkedHashMap</span><br><span class="line">是 HashMap 的一个子类，保存了记录的插入顺序；</span><br><span class="line"><span class="number">2.4</span> SortMap 接口</span><br><span class="line">TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序</span><br><span class="line"></span><br><span class="line">HashMap 是线程不安全的,HashMap 是一个接口,是 Map的一个子接口,是将键映射到值得对象,不允许键值重复,允许空键和空值;由于非线程安全, HashMap的效率要较 HashTable 的效率高一些.</span><br><span class="line">HashTable 是线程安全的一个集合,不允许 <span class="keyword">null</span> 值作为一个 key 值或者 <span class="keyword">Value</span> 值;</span><br><span class="line">HashTable 是 sychronize(同步化),多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;</span><br><span class="line"></span><br><span class="line">左连接，右连接，内连接（以小表驱动大表）</span><br><span class="line">区别：左连接返回包括左表中的所有记录和右表中连接字段相等的记录；右连接返回包括右表中的所有记录和左表中连接字段相等的记录；内连接只返回两个表中连接字段相等的行；全外连接返回左右表中所有的记录和左右表中连接字段相等的记录。</span><br><span class="line"></span><br><span class="line">对反射的理解</span><br><span class="line">反射机制（Reflection）是指动态获取类信息、动态调用类方法的功能</span><br><span class="line"></span><br><span class="line">说一下SpringMvc的工作流程</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img-blog.csdnimg.cn/20210306223048434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzYwMTM1OQ==,size_16,color_FFFFFF,t_70" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>几个字节，<span class="type">int</span>几个字节</span><br><span class="line"><span class="number">8</span>，<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>占用<span class="number">8</span>个字节（<span class="number">64</span>位），可以存储双精度浮点数。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>占用<span class="number">4</span>个字节（<span class="number">32</span>位），可以存储整数。</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>和<span class="type">int</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="type">integer</span> a <span class="operator">=</span> <span class="number">125</span>会发生什么</span><br><span class="line"></span><br><span class="line"><span class="keyword">equals</span>重写还需要做什么</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span>和<span class="keyword">equals</span>的区别</span><br><span class="line"></span><br><span class="line">jvm常用参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>一个对象，整个生命周期是什么样子的</span><br><span class="line"></span><br><span class="line">G1垃圾回收器</span><br><span class="line"></span><br><span class="line">并发编程用的哪些容器</span><br><span class="line"></span><br><span class="line">countdownlanuch有任务失败了，怎么办</span><br><span class="line"></span><br><span class="line">tcp和udp</span><br><span class="line"></span><br><span class="line">tcp限流怎么做</span><br><span class="line"></span><br><span class="line">tcp客户端没有找到服务端，那么他的状态机是什么</span><br><span class="line"></span><br><span class="line">拆包粘包</span><br><span class="line"></span><br><span class="line">springboot轻便的原因</span><br><span class="line"></span><br><span class="line">单例模式怎么实现</span><br><span class="line"></span><br><span class="line">指令重排序依赖于什么情况</span><br><span class="line"></span><br><span class="line">hashmap线程安全吗，在什么时候会线程不安全</span><br><span class="line"></span><br><span class="line">hashmap怎么扩容的</span><br><span class="line"></span><br><span class="line">慢<span class="keyword">sql</span>优化思路</span><br><span class="line"></span><br><span class="line">对<span class="number">500</span>w数据量的表更新，没加索引，会发生什么</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">java ee/se/me区别?</span><br><span class="line"></span><br><span class="line">jdk jre区别?</span><br><span class="line"></span><br><span class="line">java常用的命令有哪些?</span><br><span class="line"></span><br><span class="line">java的数据类型以及应用场景</span><br><span class="line"></span><br><span class="line">java的语法</span><br><span class="line"></span><br><span class="line">java泛型</span><br><span class="line">Java 泛型（generics）是 JDK <span class="number">5</span> 中引入的一个新特性，泛型的本质是参数化类型，强制类型转换</span><br><span class="line"></span><br><span class="line">说一下stream</span><br><span class="line"></span><br><span class="line">说一下马文?没用过这时啥?后来才了解是梅文maven,说一下常用命令</span><br><span class="line">maven clean：对项目进行清理，删除target目录下编译的内容</span><br><span class="line">maven compile：编译项目源代码</span><br><span class="line">maven test：对项目进行运行测试</span><br><span class="line">maven packet：打包文件并存放到项目的target目录下，打包好的文件通常都是编译后的<span class="keyword">class</span>文件</span><br><span class="line"><span class="symbol">maven</span> <span class="symbol">install</span>：在本地仓库生成仓库的安装包，可供其他项目引用，同时打包后的文件放到项目的<span class="symbol">target</span>目录下</span><br><span class="line"></span><br><span class="line"><span class="symbol">maven</span>怎么解决版本冲突</span><br><span class="line"></span><br><span class="line"><span class="symbol">maven</span>怎么统一管理版本号</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span>的常用命令</span><br><span class="line"></span><br><span class="line">怎么解决合并冲突</span><br><span class="line"></span><br><span class="line">项目帖子的字段如何设计的?内容字段设计的类型是什么?</span><br><span class="line"></span><br><span class="line">帖子内容如果支持图片,你会怎么设计?</span><br><span class="line"></span><br><span class="line"><span class="symbol">mybatis</span> <span class="symbol">plus</span>的使用以及优点?</span><br><span class="line"></span><br><span class="line">让你实现一下<span class="symbol">mybatis</span> <span class="symbol">plus</span>你会怎么做,比如反射?</span><br><span class="line"></span><br><span class="line"><span class="symbol">spring</span>和<span class="symbol">springboot</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="symbol">springboot</span>怎么做到的自动装配</span><br><span class="line"></span><br><span class="line"><span class="symbol">spring</span>和<span class="symbol">springboot</span>项目部署有什么不同</span><br><span class="line"></span><br><span class="line">怎么部署一个<span class="symbol">java</span>项目上线</span><br><span class="line"></span><br><span class="line"><span class="symbol">docker</span>常用命令</span><br><span class="line"></span><br><span class="line"><span class="symbol">docker</span>集群怎么统一管理</span><br><span class="line"></span><br><span class="line"><span class="symbol">dockerfile</span>相关</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">怎么用的Oss</span><br><span class="line"></span><br><span class="line">项目中用到了那些Java类</span><br><span class="line"></span><br><span class="line">用了哪些集合</span><br><span class="line"></span><br><span class="line">HashMap的<span class="built_in">Key</span>&#x27;Value讲讲。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Key</span>为什么不重复</span><br><span class="line"></span><br><span class="line">能讲讲链表到树怎么实现的（不会）</span><br><span class="line"></span><br><span class="line">ArrayList怎么遍历的</span><br><span class="line"></span><br><span class="line">Stream流你怎么用的</span><br><span class="line"></span><br><span class="line">Srteam常用方法</span><br><span class="line"></span><br><span class="line">创建多线程的方式</span><br><span class="line">新建状态</span><br><span class="line">就绪状态</span><br><span class="line">运行状态</span><br><span class="line">阻塞状态</span><br><span class="line">死亡状态</span><br><span class="line"></span><br><span class="line">线程池创建用的那个类</span><br><span class="line">ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">线程阻塞<span class="built_in">wait</span>与<span class="built_in">sleep</span>的区别：</span><br><span class="line">字面意思理解为，<span class="built_in">wait</span>为等待，直到被唤醒；而<span class="built_in">sleep</span>为睡眠，直到设定的时间，所以<span class="built_in">wait</span>需要手动唤醒，而<span class="built_in">sleep</span>不需要。</span><br><span class="line"></span><br><span class="line">io使用过吗？</span><br><span class="line"></span><br><span class="line">Spring用到了哪些注解</span><br><span class="line"></span><br><span class="line">Mybatisplus你是自己写sql吗？</span><br><span class="line"></span><br><span class="line">介绍一下MybatisPlus你用了那些方法。</span><br><span class="line"></span><br><span class="line">查询的时候List能用quryWapper吗？</span><br><span class="line"></span><br><span class="line">Mybatisplus兼容jdk8的用过吗？（没有）</span><br><span class="line"></span><br><span class="line">＃&#123;&#125;和$&#123;&#125;讲讲</span><br><span class="line"></span><br><span class="line">mybatis的注解用过吗</span><br><span class="line"></span><br><span class="line">Aop了解吗？</span><br><span class="line"></span><br><span class="line">自动装配能讲讲吗？</span><br><span class="line"></span><br><span class="line">Spring怎么管理bean</span><br><span class="line"></span><br><span class="line">redis有用到锁吗？</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">为什么走<span class="keyword">Java路线，Java与C++相比，优势在哪？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说hashCode方法？</span><br><span class="line"></span><br><span class="line">说说你了解哪些哈希集合，详细说说HashMap的实现和扩容机制及扩容可能会出现什么问题？</span><br><span class="line"></span><br><span class="line">详细说说<span class="keyword">Java里面的异常机制，以及常见的运行时异常和必检异常</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说<span class="keyword">syncronized关键字和用法，底层实现原理？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">抽象类和接口的区别？接口的设计在<span class="keyword">JDK1.8之前和之后有什么变化？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说线程创建的方式，你用过哪些？重点说说线程池中的三大方法和七大参数四大拒绝策略？</span><br><span class="line"></span><br><span class="line">线程池中线程是不是越多越好？线程创建需要耗费哪些资源？针对CPU密集型和IO密集型线程数如何设置？</span><br><span class="line"></span><br><span class="line">说说<span class="keyword">JVM中的内存区域？从GC的角度堆被如何划分了？每个区域采用何种垃圾回收算法？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">新生代中又分为那几块区域？说说轻GC（MinorGC）的基本过程</span><br><span class="line"></span><br><span class="line">说说TCP与UDP的区别，TCP数据包的结构，包含哪些字段？TCP的拥塞控制过程？</span><br><span class="line"></span><br><span class="line">说说Redis的基本数据类型，你在项目中是使用的是哪些，为什么这么用？</span><br><span class="line"></span><br><span class="line">讲讲Spring事务管理，如何使用？</span><br><span class="line"></span><br><span class="line">详细说说ACID是什么，如何保证？和 MySQL事务隔离级别及能解决哪些问题？</span><br><span class="line"></span><br><span class="line">MySQL索引底层是什么？为什么采用<span class="keyword">B+树？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">MySQL索引什么时候失效？结合<span class="keyword">B+树说说为什么会失效？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说SpringCloud的基本组件？</span><br><span class="line"></span><br><span class="line">索引底层的数据结构了解吗</span><br><span class="line"></span><br><span class="line"><span class="keyword">b+树的特性，除了访问快还有哪些</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">一步步分析为什么<span class="keyword">B+树适合作为索引的结构 </span>以及索引原理 </span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">一个url请求在网络中会经历什么</span><br><span class="line">* <span class="number">1.</span>输入url <span class="number">2.</span>DNS域名解析 <span class="number">3.</span>建立TCP连接 <span class="number">4.</span>发送HTTPRequest <span class="number">5.</span>Web服务器 <span class="number">6.</span>应用服务器Servlet处理请 求 <span class="number">7.</span>关闭TCP连接 <span class="number">8.</span>渲染相应页面</span><br><span class="line"></span><br><span class="line">gc判断对象可回收的方法</span><br><span class="line">* <span class="number">1.</span>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数器+<span class="number">1</span>，引用释放时计算器 <span class="number">-1</span>，计数为<span class="number">0</span>时可以回收。<span class="number">2.</span>可达性分析：从GC Roots开始向下收索，搜索走过的路径成为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</span><br><span class="line"></span><br><span class="line">gc的过程是什么，<span class="keyword">new</span><span class="type"></span>一个新的对象，但是新生代和老生代都已经满了</span><br><span class="line">* 新生代 GC（Minor GC）:<span class="type"></span>指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</span><br><span class="line">老年代 GC（Major GC/Full GC）:<span class="type"></span>指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 <span class="number">10</span> 倍以上。</span><br><span class="line"></span><br><span class="line">线程池的类型，线程池的参数</span><br><span class="line">*线程池的类型:<span class="type"></span></span><br><span class="line"><span class="number">1</span>、<span class="keyword">new</span><span class="type">CachedThreadPool</span></span><br><span class="line">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span><br><span class="line">这种类型的线程池特点是：</span><br><span class="line">工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</span><br><span class="line">如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为<span class="number">1</span>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</span><br><span class="line">在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">new</span><span class="type">FixedThreadPool</span></span><br><span class="line">创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</span><br><span class="line">FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">new</span><span class="type">SingleThreadExecutor</span></span><br><span class="line">创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">new</span><span class="type">ScheduleThreadPool</span></span><br><span class="line">创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</span><br><span class="line"><span class="number">5</span>、<span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span></span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行<span class="number">1</span>个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。</span><br><span class="line">*线程池的参数: <span class="type"></span></span><br><span class="line">corePoolSize：核心线程数</span><br><span class="line">maximumPoolSize：最大线程数</span><br><span class="line">keepAliveTime：空闲线程存活时间</span><br><span class="line">unit：时间单位</span><br><span class="line">workQueue：工作队列</span><br><span class="line">threadFactory：线程工厂</span><br><span class="line">handler：拒绝策略</span><br><span class="line"></span><br><span class="line">mysql的索引了解吗，索引的原则有哪些，索引越多越好吗?</span><br><span class="line">* 索引是帮助MySQL高效获取数据的数据结构（以空间换时间）</span><br><span class="line">建立索引的原则: <span class="type"></span></span><br><span class="line"><span class="number">1.</span>选择唯一性索引 <span class="number">2.</span>为经常需要排序、分组和联合操作的字段建立索引 <span class="number">3.</span>为常作为查询条件的字段建立索引 <span class="number">4.</span></span><br><span class="line">太多索引会占用很多的索引表空间，甚至比存储一条记录更多。导致更新操作速度慢 <span class="number">5.</span>尽量使用数据量少的索引 <span class="number">6.</span>尽量使用前缀来索引 <span class="number">7.</span>删除不再使用或者很少使用的索引 <span class="number">8.</span>最左前缀匹配原则，非常重要的原则 <span class="number">9.</span>=和<span class="keyword">in</span>可以乱序 <span class="number">10.</span>尽量选择区分度高的列作为索引 <span class="number">11.</span>索引列不能参与计算，保持列“干净” <span class="number">12.</span>尽量的扩展索引，不要新建索引 <span class="number">13.</span>当单个索引字段查询数据很多，区分度都不是很大时，则需要考虑建立联合索引来提高查询效率</span><br><span class="line"></span><br><span class="line">spring ioc和aop是什么，简单介绍一下</span><br><span class="line">IoC，意为控制反转，AOP，意为面向切面编程。</span><br><span class="line">Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</span><br><span class="line"></span><br><span class="line">说一下springclound</span><br><span class="line">分布式微服务架构的一站式解决方案，它提供了很多组件用来解决了分布式架构所带来的一些问题。</span><br><span class="line"></span><br><span class="line">说一下redis的使用场景</span><br><span class="line">缓存、排行榜、计数器、分布式会话、分布式锁、社交网络、最新列表、消息系统</span><br><span class="line"></span><br><span class="line">redis如何于数据库保持数据一致性</span><br><span class="line">* 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</span><br><span class="line">第一种方案：采用延时双删策略+缓存超时设置  在写库前后都进行redis.del(key)操作，并且设定合理超时时间。</span><br><span class="line">第二种方案：异步更新缓存(基于订阅binlog的同步机制)</span><br><span class="line"></span><br><span class="line">线程池的执行流程</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230221173916811.png" alt="image-20230221173916811" style="zoom:60%"><h5 id="用户注册使用的SpringSecurity和Jwt-讲一讲流程。token过期你怎么处理"><a href="#用户注册使用的SpringSecurity和Jwt-讲一讲流程。token过期你怎么处理" class="headerlink" title="用户注册使用的SpringSecurity和Jwt@讲一讲流程。token过期你怎么处理"></a>用户注册使用的SpringSecurity和Jwt@讲一讲流程。token过期你怎么处理</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">用户注册过程使用SpringSecurity和Jwt可以分为以下步骤：</span><br><span class="line"></span><br><span class="line">用户提交注册表单后，后端接收到请求，进行表单验证，如果验证通过则将用户信息保存到数据库中。</span><br><span class="line"></span><br><span class="line">用户登录时，后端接收到登录请求，验证用户名和密码是否匹配，如果匹配则生成一个Jwt token，将其作为响应返回给客户端。</span><br><span class="line"></span><br><span class="line">客户端在以后的请求中，将Jwt token添加到请求头中，后端通过Jwt验证token的合法性，并获取其中的用户信息，进行相应操作。</span><br><span class="line"></span><br><span class="line">具体实现中，可以使用SpringSecurity提供的JwtAuthenticationFilter拦截请求，验证token的合法性，并将用户信息保存到SpringSecurity的上下文中，方便后续操作。同时，可以使用JwtTokenProvider类生成和验证token。</span><br><span class="line"></span><br><span class="line">当Jwt token过期时，可以使用<span class="built_in">ref</span>resh token机制来处理。具体实现中，可以在生成token时，同时生成一个<span class="built_in">ref</span>resh token，并将其保存到数据库中。当token过期时，客户端可以使用<span class="built_in">ref</span>resh token来获取一个新的token。具体流程如下：</span><br><span class="line"></span><br><span class="line">客户端发送一个请求，包含过期的token和<span class="built_in">ref</span>resh token。</span><br><span class="line"></span><br><span class="line">后端验证<span class="built_in">ref</span>resh token的合法性，并生成一个新的token。</span><br><span class="line"></span><br><span class="line">后端将新的token和<span class="built_in">ref</span>resh token作为响应返回给客户端，并将新的token保存到SpringSecurity的上下文中。</span><br><span class="line"></span><br><span class="line">客户端在以后的请求中，使用新的token来进行操作。</span><br><span class="line"></span><br><span class="line">需要注意的是，<span class="built_in">ref</span>resh token也有过期时间，需要定期更新。此外，<span class="built_in">ref</span>resh token需要进行加密处理，以防止泄露。</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Redis</span>是一种基于内存的数据存储系统，支持多种数据类型。以下是<span class="variable">Redis</span>的基本数据类型：</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>：字符串类型，可以存储任意类型的数据，包括数字、文本、二进制数据等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hash</span>：哈希类型，可以存储键值对形式的数据，类似于<span class="variable">Java</span>中的<span class="built_in">Map</span>。</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>：列表类型，可以存储一组有序的数据，支持在列表头部和尾部进行插入和删除操作。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>：集合类型，可以存储一组无序的、不重复的数据，支持交集、并集、差集等操作。</span><br><span class="line"></span><br><span class="line"><span class="variable">Sorted</span> <span class="built_in">Set</span>：有序集合类型，可以存储一组有序的、不重复的数据，每个数据都有一个分值，支持根据分值进行排序。</span><br><span class="line"></span><br><span class="line">在我的项目中，我们主要使用了<span class="variable">Redis</span>的<span class="built_in">String</span>、<span class="built_in">Hash</span>、<span class="built_in">List</span>和<span class="built_in">Set</span>四种类型。具体使用场景如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>：用于缓存一些简单的数据，例如用户登录信息、验证码等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hash</span>：用于缓存一些复杂的数据，例如用户信息、商品信息等，可以使用哈希表的形式存储多个字段。</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>：用于实现队列和栈等数据结构，例如消息队列、操作日志等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>：用于实现一些复杂的业务逻辑，例如排行榜、热门商品等。</span><br><span class="line"></span><br><span class="line">我们选择使用这些数据类型，主要是因为它们可以很好地满足我们的业务需求，同时<span class="variable">Redis</span>也提供了丰富的操作接口，方便我们对数据进行操作和管理。</span><br><span class="line"></span><br><span class="line">需要注意的是，在使用<span class="variable">Redis</span>时，需要注意数据类型的选择和数据存储的大小，避免出现数据丢失、性能问题等情况。同时，需要对<span class="variable">Redis</span>进行定期备份和监控，保证系统的可靠性和稳定性。</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL索引失效主要有以下几种情况：</span><br><span class="line"></span><br><span class="line">数据量太小：如果表中的数据量太小，那么MySQL可能会直接进行全表扫描，而不是使用索引进行优化。</span><br><span class="line"></span><br><span class="line">索引列类型不匹配：如果查询条件与索引列数据类型不匹配，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上使用了函数或表达式：如果查询条件中使用了函数或表达式，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上使用了<span class="keyword">LIKE</span>操作符：如果查询条件中使用了<span class="keyword">LIKE</span>操作符，那么MySQL可能会只使用索引的前缀部分进行查询，而不是使用整个索引。</span><br><span class="line"></span><br><span class="line">索引列上使用了<span class="keyword">IS</span> <span class="keyword">NULL</span>或<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>操作符：如果查询条件中使用了<span class="keyword">IS</span> <span class="keyword">NULL</span>或<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>操作符，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上存在大量重复数据：如果索引列上存在大量重复数据，那么MySQL可能会放弃使用索引进行优化。</span><br><span class="line"></span><br><span class="line">在B+树中，索引失效的主要原因是因为查询的数据不在叶子节点上，导致需要进行多次磁盘读取才能找到目标数据。例如，如果查询的数据在B+树的叶子节点之外，那么MySQL可能会放弃使用索引进行查询，而进行全表扫描。</span><br><span class="line"></span><br><span class="line">此外，如果B+树的分裂和合并不平衡，也可能导致索引失效。如果分裂过于频繁，那么B+树的高度可能会增加，导致查询时需要进行更多的磁盘读取。如果合并过于频繁，那么B+树的节点数量可能会减少，导致索引的覆盖率降低，查询时需要进行更多的磁盘读取。</span><br><span class="line"></span><br><span class="line">因此，为了避免MySQL索引失效，需要合理地设计表结构、索引和查询语句，同时需要对MySQL进行优化和调优，保证系统的性能和稳定性。</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/IO/">IO</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/640ed8e3f144a010075b4567.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/wechat.png" alt="wechat"></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/alipay.png" alt="alipay"></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://pic.imgdb.cn/item/640daf34f144a010075844fd.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">obscureline</div><div class="author-info__description">Welcome To ObscureLine Home</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">34</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/obscureline"><i></i><span>🐻‍❄️ Fellow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/obscureline" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:obscureline@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的Java知识博客, 本博客是一个总结Java知识的平台，主要涵盖Java基础、主流框架、底层原理等方向。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E4%BD%BF%E7%94%A8%E7%9A%84SpringSecurity%E5%92%8CJwt-%E8%AE%B2%E4%B8%80%E8%AE%B2%E6%B5%81%E7%A8%8B%E3%80%82token%E8%BF%87%E6%9C%9F%E4%BD%A0%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">用户注册使用的SpringSecurity和Jwt@讲一讲流程。token过期你怎么处理</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image:url(https://pic.imgdb.cn/item/640ed8e3f144a010075b4567.png)"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By obscureline</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a>&nbsp;<a target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer src="/js/light.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var e=document.getElementById("recent-posts");e&&"/"==location.pathname&&(console.log("已挂载github calendar"),e.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://gitcalendar.zfe.space/api/?obscureline",["#ebedf0","#fdcdec","#fc9bd9","#fa6ac5","#f838b2","#f5089f","#c4067e","#92055e","#540336","#48022f","#30021f"],"obscureline")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>function history_calendar_injector_config(){var i=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载history_calendar"),i.insertAdjacentHTML("afterbegin",'<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>')}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&history_calendar_injector_config()</script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="/posts/,/about/".split(","),cpage=location.pathname,epage="/",qweather_key="b16a1fa0e63c46a4b8f28abfb06ae3fe",gaud_map_key="e2b04289e870b005374ee030148d64fd&s=rsv3",baidu_ak_key="undefined",flag=0,clock_rectangle="112.6534116,27.96920845",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;("all"===epage&&0==flag||epage===cpage)&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script></body></html>