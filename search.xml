<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SQL概念</title>
      <link href="/2024/02/07/11.SQL%E6%A6%82%E5%BF%B5/"/>
      <url>/2024/02/07/11.SQL%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL概念"><a href="#SQL概念" class="headerlink" title="SQL概念"></a>SQL概念</h1><h2 id="1-MyISAM和InnoDB的区别有哪些"><a href="#1-MyISAM和InnoDB的区别有哪些" class="headerlink" title="1.MyISAM和InnoDB的区别有哪些"></a>1.MyISAM和InnoDB的区别有哪些</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InnoDB支持事务, MyISAM不支持.</span><br><span class="line">InnoDB支持行级锁, MyISAM支持表级锁.</span><br><span class="line">InnoDB支持多版本并发控制(MVVC), MyISAM不支持.</span><br><span class="line">InnoDB支持外键, MyISAM不支持.</span><br><span class="line">MyISAM支持全文索引, InnoDB部分版本不支持(但可以使用Sphinx插件)</span><br></pre></td></tr></table></figure><h2 id="2-MySQL事务的隔离级别-分别有什么特点"><a href="#2-MySQL事务的隔离级别-分别有什么特点" class="headerlink" title="2.MySQL事务的隔离级别,分别有什么特点"></a>2.MySQL事务的隔离级别,分别有什么特点</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.读未提交(RU): 一个事务还没提交时, 它做的变更就能被别的事务看到.</span><br><span class="line"><span class="number">2</span>.读提交(RC): 一个事务提交之后, 它做的变更才会被其他事务看到.</span><br><span class="line"><span class="number">3</span>.可重复读(RR): 一个事务执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的. 当然在可重复读隔离级别下, 未提交变更对其他事务也是不可见的.</span><br><span class="line"><span class="number">4</span>.串行化(S): 对于同一行记录, 读写都会加锁. 当出现读写锁冲突的时候, 后访问的事务必须等前一个事务执行完成才能继续执行.</span><br></pre></td></tr></table></figure><h2 id="3-数据库范式"><a href="#3-数据库范式" class="headerlink" title="3.数据库范式"></a>3.数据库范式</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">三范式的定义如下:</span></span><br><span class="line"></span><br><span class="line"><span class="section">第一范式(1NF):属性不可再分</span></span><br><span class="line"><span class="section">满足第一范式的表具有以下几个特征:</span></span><br><span class="line">每个字段值都不可再分解;</span><br><span class="line">每个记录都能被唯一地区分;</span><br><span class="line">每个属性只具有单一属性;</span><br><span class="line">每个字段均为原子值,没有重复的组。</span><br><span class="line"></span><br><span class="line"><span class="section">第二范式(2NF):满足1NF,并且每个非主属性完全依赖于候选键</span></span><br><span class="line"><span class="section">满足第二范式的表需要满足:</span></span><br><span class="line">满足第一范式;</span><br><span class="line">表中的每个非主属性必须完全依赖于候选键。</span><br><span class="line"></span><br><span class="line"><span class="section">第三范式(3NF):满足2NF,并且任何非主属性不依赖于其它非主属性</span></span><br><span class="line"><span class="section">满足第三范式的表需要满足:</span></span><br><span class="line">满足第二范式;</span><br><span class="line">消除传递依赖。表中的每个非主属性仅依赖于候选键,而不依赖于其它非主属性。</span><br><span class="line"></span><br><span class="line">总结来说,三范式的设计目标是消除数据冗余,保证数据的唯一性和完整性。符合三范式的数据库设计可以减少数据异常,简化数据库操作,提高数据维护的效率。</span><br></pre></td></tr></table></figure><h2 id="4-MySQL锁"><a href="#4-MySQL锁" class="headerlink" title="4.MySQL锁"></a>4.MySQL锁</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</span><br><span class="line">2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</span><br><span class="line">3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</span><br></pre></td></tr></table></figure><h2 id="5-常见命令"><a href="#5-常见命令" class="headerlink" title="5.常见命令"></a>5.常见命令</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NOW</span>()和<span class="built_in">CURRENT_DATE</span>()</span><br><span class="line"><span class="built_in">NOW</span>()命令用于显示当前年份，月份，日期，小时，分钟和秒。</span><br><span class="line"><span class="built_in">CURRENT_DATE</span>()仅显示当前年份，月份和日期。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、<span class="built_in">CONCAT</span>(A,B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。</span><br><span class="line"><span class="number">2</span>、<span class="built_in">FORMAT</span>(X,D)- 格式化数字 X 到 D 有效数字。</span><br><span class="line"><span class="number">3</span>、<span class="built_in">CURRDATE</span>(), <span class="built_in">CURRTIME</span>()- 返回当前日期或时间。</span><br><span class="line"><span class="number">4</span>、<span class="built_in">NOW</span>()– 将当前日期和时间作为一个值返回。</span><br><span class="line"><span class="number">5</span>、<span class="built_in">MONTH</span>()， <span class="built_in">DAY</span>()，<span class="built_in">YEAR</span>()，<span class="built_in">WEEK</span>()，<span class="built_in">WEEKDAY</span>() – 从日期值中提取给定数据。</span><br><span class="line"><span class="number">6</span>、<span class="built_in">HOUR</span>()，<span class="built_in">MINUTE</span>()，<span class="built_in">SECOND</span>() – 从时间值中提取给定数据。</span><br><span class="line"><span class="number">7</span>、<span class="built_in">DATEDIFF</span>(A，B) – 确定两个日期之间的差异， 通常用于计算年龄</span><br><span class="line"><span class="number">8</span>、<span class="built_in">SUBTIMES</span>(A，B) – 确定两次之间的差异。</span><br><span class="line"><span class="number">9</span>、<span class="built_in">FROMDAYS</span>(INT) – 将整数天数转换为日期值。</span><br></pre></td></tr></table></figure><h2 id="6-索引的底层实现原理和优化"><a href="#6-索引的底层实现原理和优化" class="headerlink" title="6.索引的底层实现原理和优化"></a>6.索引的底层实现原理和优化</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">B+树，经过优化的B+树</span><br><span class="line">主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用<span class="keyword">ENUM</span></span><br><span class="line"><span class="number">2</span>、使用连接(<span class="keyword">JOIN</span>)来代替子查询</span><br><span class="line"><span class="number">3</span>、适用联合(<span class="keyword">UNION</span>)来代替手动创建的临时表</span><br><span class="line"><span class="number">4</span>、事务处理</span><br><span class="line"><span class="number">5</span>、锁定表、优化事务处理</span><br><span class="line"><span class="number">6</span>、适用外键，优化锁定表</span><br><span class="line"><span class="number">7</span>、建立索引</span><br><span class="line"><span class="number">8</span>、优化查询语句</span><br></pre></td></tr></table></figure><h2 id="7-索引失效"><a href="#7-索引失效" class="headerlink" title="7.索引失效"></a>7.索引失效</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SQL</span>索引失效的<span class="number">11</span>种情况详析</span><br><span class="line"><span class="number">1.</span> 模糊查询（<span class="keyword">LIKE</span> <span class="string">&#x27;%...%&#x27;</span>）</span><br><span class="line">在<span class="keyword">SQL</span>语句中使用<span class="keyword">LIKE</span> <span class="string">&#x27;%...%&#x27;</span>方式进行模糊查询时，由于需要进行全表扫描从而导致索引失效。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询姓名中包含“张”的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="type">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%张%&#x27;</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于需要对每一条记录都进行字符比较，导致无法利用索引从而进行全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 索引字段类型与查询条件类型不一致</span><br><span class="line">当索引字段类型与查询条件类型不一致时，也会导致索引失效。比如，索引字段为字符串类型，而查询条件为数值类型，或者索引字段为数值类型，而查询条件为字符串类型。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询年龄大于<span class="number">20</span>岁的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age &gt; <span class="string">&#x27;20&#x27;</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于age字段为数值类型，而查询条件为字符串类型，导致无法利用索引从而进行全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="keyword">OR</span>查询条件</span><br><span class="line">当<span class="keyword">SQL</span>语句中出现<span class="keyword">OR</span>查询条件时，也会导致索引失效。因为<span class="keyword">OR</span>查询条件可能涉及多个索引字段，无法进行索引优化。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询数学成绩大于<span class="number">80</span>分或英语成绩大于<span class="number">80</span>分的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> math_score &gt; <span class="number">80</span> <span class="keyword">OR</span> english_score &gt; <span class="number">80</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于<span class="keyword">OR</span>条件无法利用索引进行优化，需要进行全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> <span class="keyword">IN</span>查询条件</span><br><span class="line">当<span class="keyword">SQL</span>语句中出现<span class="keyword">IN</span>查询条件时，也会导致索引失效。<span class="keyword">IN</span>查询条件是指在查询语句中使用<span class="keyword">IN</span>关键字，后面跟随着多个取值。因为<span class="keyword">IN</span>查询条件可能涉及多个索引字段，无法进行索引优化。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询英语成绩在<span class="number">70</span> ~ <span class="number">80</span>分之间的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> english_score <span class="keyword">IN</span> (<span class="number">70</span>, <span class="number">71</span>, <span class="number">72</span>, <span class="number">73</span>, <span class="number">74</span>, <span class="number">75</span>, <span class="number">76</span>, <span class="number">77</span>, <span class="number">78</span>, <span class="number">79</span>, <span class="number">80</span>);</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于<span class="keyword">IN</span>条件无法利用索引进行优化，需要进行全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span>子句中使用函数或表达式</span><br><span class="line">当<span class="keyword">SQL</span>语句中在<span class="keyword">ORDER</span> <span class="keyword">BY</span>子句中使用函数或表达式时，也会导致索引失效。因为通过函数或表达式对索引字段进行处理后，无法使用索引进行排序。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询数学成绩并按照平方根值进行降序排列。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> SQRT(math_score) <span class="keyword">DESC</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于SQRT函数对索引字段进行了处理，无法使用索引进行排序，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 计算字段</span><br><span class="line">当<span class="keyword">SQL</span>语句中在<span class="keyword">SELECT</span>子句或<span class="keyword">WHERE</span>子句中使用计算字段时，也会导致索引失效。因为计算字段不是数据表中的真实字段，无法建立索引。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询数学成绩加上英语成绩的总分数大于<span class="number">160</span>分的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> math_score + english_score &gt; <span class="number">160</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于加法运算不是一个真实的字段，无法建立索引，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> <span class="keyword">JOIN</span>操作中没有使用索引字段</span><br><span class="line">当<span class="keyword">SQL</span>语句中进行<span class="keyword">JOIN</span>操作时，如果没有使用索引字段，则<span class="keyword">JOIN</span>操作会使用全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询每个学生所属的班级名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> students.*, classes.name </span><br><span class="line"><span class="keyword">FROM</span> students <span class="keyword">JOIN</span> classes </span><br><span class="line"><span class="keyword">ON</span> students.class_id = classes.id;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，如果没有为students表的class_id和classes表的id字段建立索引，则<span class="keyword">JOIN</span>操作会使用全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 未加<span class="keyword">LIMIT</span>限制</span><br><span class="line">当<span class="keyword">SQL</span>查询语句未加<span class="keyword">LIMIT</span>限制时，也会导致索引失效。如果返回的结果集很大，查询操作可能会使用全表扫描，从而导致索引失效。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询数学成绩最高的<span class="number">10</span>名学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> math_score <span class="keyword">DESC</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，如果没有限制返回的结果集个数，则会返回整张表的数据，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 隐式类型转换</span><br><span class="line">当<span class="keyword">SQL</span>查询语句中出现隐式类型转换时，也会导致索引失效。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询编号为<span class="number">1</span>的学生信息。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于id字段为数值类型，而查询条件为字符串类型，会进行隐式类型转换，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span> 聚合函数</span><br><span class="line">当<span class="keyword">SQL</span>查询语句中使用聚合函数时，也会导致索引失效。</span><br><span class="line"></span><br><span class="line">示例：假设需要查询数学成绩的平均分数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> AVG(math_score) <span class="keyword">FROM</span> students;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于使用了聚合函数AVG，需要对所有记录进行计算，从而导致无法使用索引，从而导致索引失效。</span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 字段长度过长</span><br><span class="line">当<span class="keyword">SQL</span>查询语句中进行索引操作的字段长度过长时，也会导致索引失效。因为字段长度过长会导致索引树变得更宽，从而降低索引的效率。</span><br><span class="line"></span><br><span class="line">示例：假设<span class="type">name</span>字段长度为<span class="number">1000</span>个字符，需要对该字段进行查询。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> <span class="type">name</span> = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">在执行以上<span class="keyword">SQL</span>查询语句时，由于<span class="type">name</span>字段长度过长，无法快速建立索引，从而导致索引失效。</span><br></pre></td></tr></table></figure><h2 id="8-主从复制读写分离"><a href="#8-主从复制读写分离" class="headerlink" title="8.主从复制读写分离"></a>8.主从复制读写分离</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是通过将 Mysql 的某一台主机的数据复制到其它主机（slaves）上，并重新执行一遍来实现的</span><br><span class="line"><span class="bullet">1.</span> 主服务器把更新记录到二进制日志文件中。 </span><br><span class="line"><span class="bullet">2.</span> 从服务器把主服务器的二进制日志拷贝到自己的中继日志（replay log）中。 </span><br><span class="line"><span class="bullet">3.</span> 从服务器重做中继日志中的时间，把更新应用到自己的数据库上。</span><br></pre></td></tr></table></figure><h2 id="一千万条数据的表-如何分页查询"><a href="#一千万条数据的表-如何分页查询" class="headerlink" title="一千万条数据的表,如何分页查询"></a>一千万条数据的表,如何分页查询</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据量过大的情况下, <span class="keyword">limit</span> <span class="keyword">offset</span> 分页会由于扫描数据太多而越往后查询越慢. 可以配合当前页最后一条ID进行查询, <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> id &gt; #&#123;ID&#125; <span class="keyword">LIMIT</span> #&#123;<span class="keyword">LIMIT</span>&#125; . 当然, 这种情况下ID必须是有序的, 这也是有序ID的好处之一.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/08/20/38.Docker/"/>
      <url>/2023/08/20/38.Docker/</url>
      
        <content type="html"><![CDATA[<p>容器</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热门项目2</title>
      <link href="/2023/08/19/37.%E7%83%AD%E9%97%A8%E9%A1%B9%E7%9B%AE2/"/>
      <url>/2023/08/19/37.%E7%83%AD%E9%97%A8%E9%A1%B9%E7%9B%AE2/</url>
      
        <content type="html"><![CDATA[<p>点评项目:</p><p>并发安全问题：</p><p>悲观锁 操作数据前先获取锁，确保线程串行执行（sy锁，Lock锁，互斥锁）<br>认为线程安全一定会发生</p><p>乐观锁 不加锁，只是在更新数据时去判断有没有其他线程对数据进行了修改；如果被其他线程修改，重试或异常<br>认为线程安全不一定会发生<br>1.版本号法  字段+version<br>1.1.查询库存和版本<br>1.2.根据库存和版本更新库存和版本</p><p>CAS：比较数据有没有发生变化<br>1.查询库存<br>2.根据库存更新库存<br>优化：库存&gt;0</p><p>sy锁：失败会进行重试<br>单个JVM，线程的互斥<br>锁监视器：进行线程的互斥</p><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁<br>1.多线程可见<br>2.互斥<br>3.高可用<br>4.高性能<br>5.安全性</p><p>分布式锁的实现<br>1.mysql<br>数据库本身的互斥锁机制；断开连接，自动释放锁<br>2.redis<br>setnx互斥命令；主从，集群来保证性能；通过redis的过期机制<br>3.zookeeper<br>利用节点的唯一性和有序性实现互斥；节点删除，释放锁；支持集群；安全性，临时节点</p><p>setnx lock thread1 &#x2F;&#x2F;添加锁，利用互斥特性<br>expire lock 10 &#x2F;&#x2F;添加锁过期时间，避免服务宕机引起的死锁<br>del lock &#x2F;&#x2F;释放锁，进行删除<br>使用非阻塞式</p><p>SET lock thread1 nx ex 10</p><p>获取当前线程ID<br>Thread.currentThread().getId();</p><p>redis分布式锁原理<br>利用set nx ex获取锁，设置过期时间，报错线程标示<br>释放锁时先判断线程标示是否与自己一致，一致则删除锁（利用Lua报错释放锁的原子性）</p><p>redis集群保证高可用高并发</p><p>可重入锁：同一个线程可以多次获取同一把锁<br>不可重入锁：同一个线程无法多次获取同一把锁<br>非阻塞式：不可重试，获取锁只尝试一次就返回false，没有重试机制<br>可重试：多次尝试获取锁</p><p>出现的问题：<br>1.不可重入<br>2.不可重试<br>3.超时释放<br>4.主从一致性<br>*通过成熟的框架来实现 redisson<br>基于redis的分布式工具的集合</p>]]></content>
      
      
      <categories>
          
          <category> 热门项目2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热门项目2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>热门项目1</title>
      <link href="/2023/08/18/36.%E7%83%AD%E9%97%A8%E9%A1%B9%E7%9B%AE1/"/>
      <url>/2023/08/18/36.%E7%83%AD%E9%97%A8%E9%A1%B9%E7%9B%AE1/</url>
      
        <content type="html"><![CDATA[<h2 id="Reggie"><a href="#Reggie" class="headerlink" title="Reggie"></a>Reggie</h2><p>type分类类型<br>int<br>status状态值<br>int<br>sex性别<br>str</p><p>如果你想使用boolean来对应数据库中的tinyint类型，你可以进行以下处理：<br>读取数据库中的tinyint类型值时，将其转换为boolean类型。在Java中，通常将非零值解释为true，将零值解释为false。<br>int tinyintValue &#x3D; resultSet.getInt(“column_name”);<br>boolean booleanValue &#x3D; (tinyintValue !&#x3D; 0);<br>将boolean类型值存储到数据库的tinyint类型列中时，可以使用条件语句将boolean值转换为0或1。<br>boolean booleanValue &#x3D; true;<br>int tinyintValue &#x3D; booleanValue ? 1 : 0;<br>&#x2F;&#x2F; 将tinyintValue存储到数据库中的tinyint列<br>需要注意的是，boolean类型在Java中只占用1个字节，而tinyint类型在数据库中通常占用1个字节，因此可以直接进行转换。但需要确保数据库中的tinyint列只存储0和1的值，避免其他非零值导致转换错误。</p><p>LocalDateTime和Date是Java中处理日期和时间的两个类。<br>类型不同：LocalDateTime是Java 8引入的新类型，而Date是Java旧版本中的类型。<br>精度不同：LocalDateTime可以表示年、月、日、小时、分钟、秒和毫秒，而Date只能表示年、月、日、小时、分钟和秒。<br>时区处理不同：LocalDateTime不包含时区信息，它表示的是本地日期和时间。而Date表示的是格林威治标准时间（GMT）。<br>可变性不同：LocalDateTime是不可变的，它的值不能被修改。而Date是可变的，可以通过set方法来修改日期和时间的值。<br>兼容性不同：LocalDateTime在Java 8及以后的版本中使用，而Date在Java旧版本中使用。在新的Java应用程序开发中，推荐使用LocalDateTime。<br>总结来说，LocalDateTime提供了更灵活、更精确和更易于使用的日期和时间处理方法，而Date则是相对较旧的类型，可以在旧版本的Java应用程序中使用。</p><h3 id="MySQL主从复制读写分离"><a href="#MySQL主从复制读写分离" class="headerlink" title="MySQL主从复制读写分离"></a>MySQL主从复制读写分离</h3><p><img src="https://img-blog.csdnimg.cn/d24a8674053e40bfba5d6cd3f163ef60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP55m96Zev5YWz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"><br><a href="https://img-blog.csdnimg.cn/d24a8674053e40bfba5d6cd3f163ef60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP55m96Zev5YWz,size_20,color_FFFFFF,t_70,g_se,x_16"><img src="https://img-blog.csdnimg.cn/d24a8674053e40bfba5d6cd3f163ef60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bCP5bCP55m96Zev5YWz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="沙漠中的岩石图片" title="Shiprock"></a></p><p>主从复制的原理<br>①Master节点将数据的改变记录成二进制日志（bin log），当Master上的数据发生改变时，则将其改变写入二进制日志中<br>②Slave节点会在一定时间间隔内对Master的二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I&#x2F;O线程请求 Master的二进制事件<br>③同时Master节点为每个I&#x2F;O线程启动一个dump线程，用于向其发送二进制事件，并保存至Slave节点本地的中继日志（Relay log）中<br>④Slave节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，即解析成 sql 语句逐一执行，使得其数据和 Master节点的保持一致，最后I&#x2F;O线程和SQL线程将进入睡眠状态，等待下一次被唤醒<br>复制过程有一个很重要的限制，即复制在 Slave 上是串行化的，也就是说 Master 上的并行更新操作不能在 Slave 上并行操作<br>中继日志通常会位于OS缓存中，所以中继日志的开销很小</p><p>用途及条件<br>mysql主从复制用途：<br>实时灾备，用于故障切换<br>读写分离，提供查询服务<br>备份，避免影响服务<br>必要条件：<br>主库开启binlog日志（设置log-bin参数）<br>主从server-id不同<br>从库服务器能连通主库<br>8.mysql主从复制存在的问题<br>主库宕机后，数据可能丢失<br>从库只有一个SQL Thread,主库写压力大，复制很可能延时<br>解决办法<br>半同步复制——解决数据丢失的问题<br>并行复制——解决从库复制延迟的问题<br>9.MySQL主从复制延迟<br>①master服务器高并发，形成大量事务<br>②网络延迟<br>③主从硬件设备导致——cpu主频、内存io、硬盘io<br>④本来就不是同步复制、而是异步复制<br>从库优化Mysql参数。比如增大innodb_buffer_pool_size，让更多操作在Mysql内存中完成，减少磁盘操作<br>从库使用高性能主机，包括cpu强悍、内存加大。避免使用虚拟云主机，使用物理主机，这样提升了i&#x2F;o方面性<br>从库使用SSD磁盘<br>网络优化，避免跨机房实现同步</p>]]></content>
      
      
      <categories>
          
          <category> 热门项目1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 热门项目1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合底层原理</title>
      <link href="/2023/08/12/35.%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
      <url>/2023/08/12/35.%E9%9B%86%E5%90%88%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>HashMap</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最常使用的是两个方法：<span class="built_in">Get</span> 和 <span class="built_in">Put</span></span><br><span class="line"><span class="variable">HashMap</span>数组每一个元素的初始值都是<span class="built_in">Null</span>。</span><br><span class="line"><span class="variable">HashMap</span>是一个用于存储<span class="built_in">Key</span><span class="operator">-</span><span class="built_in">Value</span>键值对的集合，每一个键值对也叫做<span class="variable">Entry</span>。这些个键值对（<span class="variable">Entry</span>）分散存储在一个数组当中，这个数组就是<span class="variable">HashMap</span>的主干。</span><br></pre></td></tr></table></figure><h3 id="最常使用的是两个方法：Get-和-Put"><a href="#最常使用的是两个方法：Get-和-Put" class="headerlink" title="最常使用的是两个方法：Get 和 Put"></a>最常使用的是两个方法：Get 和 Put</h3><p>1.Put方法的原理<br>调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。<br>(1)一个哈希函数来确定Entry的插入位置（index）index &#x3D;  Hash（“key”）index是2<br>(2)如果没有值，插入数组；如果有值，哈希碰撞，头插链表</p><p>2.Get方法的原理<br>(1)输入的Key做一次Hash映射，得到对应的index：index &#x3D;  Hash（“apple”）<br>(2)通过equals判断Key值是否相等<br>头插法的原因：HashMap的发明者认为，后插入的Entry被查找的可能性更大。</p><p>HashMap的默认长度：16【长度必须是2的幂】，之所以选择16是因为服务与从Key映射到index的Hash算法<br>HashMap负载因子，默认值为0.75f</p>]]></content>
      
      
      <categories>
          
          <category> 集合底层原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合底层原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/08/12/34.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/08/12/34.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>索引结构<br>MySQL索引是在 存储引擎层 实现的，不同的存储引擎层，有不同的索引结构，主要包含四种索引：</p><p>B+树索引最常见的索引类型<br>Hash索引底层是由 哈希表 实现 （⭐性能很强，但是！不支持范围查询）<br>空间索引（R-tree）是 MyISAM 引擎 的一个特殊索引类型，主要用于地理空间数据类型<br>全文索引（Full-text）通过建立倒排索引方式，来快速匹配文档。</p><p>1.二叉树（二叉搜索树）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">简单的树形数据结构</span><br><span class="line">二叉树的插入顺序，让左子节点的元素永远小于右子节点。这种二叉树，可以快速的查询到某一个元素</span><br></pre></td></tr></table></figure><p>2.B树（多叉搜索树）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多叉搜索树中的节点，可以存储多个元素</span><br><span class="line">即 二叉搜索树不平衡的问题，当数量足够大时，树的深度会越深，查询效率就会越低。</span><br><span class="line">在数据库存储中，树是一种常用的数据结构，其数据会存储在硬盘，那么每一次数据的读写都会在磁盘上进行读写，这一过程非常耗时。</span><br><span class="line">树的深度越大，那么磁盘读写的次数越多，带来的IO开销也越大 （所以设计出了 <span class="selector-tag">B</span>树，<span class="selector-tag">B</span>树是多叉树的一种）</span><br></pre></td></tr></table></figure><p>3.B+树</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>).<span class="keyword">B+ </span>树的所有元素(数据)，全部存放在叶子节点，即 所有的元素都会出现在叶子节点 。（<span class="keyword">B树 </span>叶子节点和非叶子节点都存储数据）</span><br><span class="line"><span class="keyword">B树 </span>的叶子节点、非叶子节点保存的是数据</span><br><span class="line"><span class="keyword">B+树 </span>的非叶子节点是不保存数据的，只起到索引作用，它的叶子节点才保存数据。</span><br><span class="line">(<span class="number">2</span>).非叶子节点，不存储数据，起到一个索引的作用</span><br><span class="line">(<span class="number">3</span>).<span class="keyword">B+ </span>树 的数据结构中，叶子节点之间形成了单向链表。每一个节点的指针，通过叶子节点指向下一个元素。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.<span class="keyword">B+树（MySQL）</span></span><br><span class="line"><span class="keyword"></span>MySQL中的 <span class="keyword">B+ </span>树，对经典的<span class="keyword">B+ </span>树结构进行了一个优化。在原基础上，叶子节点又增加了一条相邻叶子节点的指针。</span><br><span class="line">经典的<span class="keyword">B+树，结构大致一致。唯一不同的是，叶子节点之间形成了双向链表。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="number">5</span>.哈希索引</span><br><span class="line">图详解：</span><br><span class="line">看左边的表，我们对name字段创建了Hash索引，并查找杨逍</span><br><span class="line">首先对 name 采用 hash算法，得到hash值。通过生成的 hash值，映射到槽位 (杨逍，<span class="number">005</span>)。</span><br><span class="line">图中不难看到，<span class="number">005</span>的位置，产生了 hash冲突</span><br><span class="line">我们再对比 <span class="number">005</span>槽位上链表的每一个元素，即可拿到值</span><br><span class="line">特点：</span><br><span class="line">只能用于等值比较（=，in），不支持范围查询（<span class="keyword">between，&gt;，&lt; </span>… ）</span><br><span class="line">无法利用索引完成排序操作</span><br><span class="line">查询效率高（在索引中，查询小路是最高的）。在理想情况下，只需要检索一次（不发生Hash冲突的情况下）</span><br><span class="line">Memory引擎，支持Hash索引，其他不支持。但是，InnoDB引擎 有自适应 hash 功能，会根据查询条件 自动的将 <span class="keyword">B+树索引，构建为Hash索引</span></span><br></pre></td></tr></table></figure><p>B+ 树<br><a href="https://img-blog.csdnimg.cn/08069f25dad2483dab4ecb77daf99beb.png">https://img-blog.csdnimg.cn/08069f25dad2483dab4ecb77daf99beb.png</a></p><p>B+ 树（MySQL）<br><a href="https://img-blog.csdnimg.cn/f4b0dc2b499545099b1bf8fcc763c980.png">https://img-blog.csdnimg.cn/f4b0dc2b499545099b1bf8fcc763c980.png</a></p><p>Hash索引<br><a href="https://img-blog.csdnimg.cn/df85a7dd744d46be8a9a2b144af7ed34.png">https://img-blog.csdnimg.cn/df85a7dd744d46be8a9a2b144af7ed34.png</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCache</title>
      <link href="/2023/08/07/33.SpringCache/"/>
      <url>/2023/08/07/33.SpringCache/</url>
      
        <content type="html"><![CDATA[<h4 id="SpringCache框架"><a href="#SpringCache框架" class="headerlink" title="SpringCache框架"></a>SpringCache框架</h4><p>基于注解的缓存功能，具体是通过CacheManager接口来统一不同的缓存技术</p><p>CacheManager是Spring提供的各种缓存技术抽象接口</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解缓存的实现依赖于动态代理</span><br></pre></td></tr></table></figure><p>@CachePut：新增</p><p>@CacheEvict：删除</p><p>@CacheEvict：更新</p><p>@Cacheable：查询</p><h5 id="（一）核心概念"><a href="#（一）核心概念" class="headerlink" title="（一）核心概念"></a>（一）核心概念</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个应用可以有多个缓存管理器，每个缓存管理器可以有多个缓存，每个缓存可以存储多条记录。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、缓存管理器</span><br><span class="line">缓存的存储介质不同、缓存连接不同的数据库、缓存值序列化等由缓存管理器配置。缓存管理器有主次之分，默认情况下使用主（首要）缓存管理器。</span><br><span class="line">当服务内只有一个CacheManager时，默认使用此缓存管理器；当超过一个缓存管理器时，需要使用<span class="keyword">Primary</span>注解指定默认缓存管理器。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、缓存</span><br><span class="line"><span class="keyword">Cache</span>是一组配置相同缓存的集合，可以理解为命名空间，Spring <span class="keyword">Cache</span>体系下的缓存生命时间是以<span class="keyword">Cache</span>为单位的，不支持以Key为单位设置生存时间。不同的业务对应不同的缓存配置，应在缓存处予以区分。</span><br><span class="line">CacheName应具有显著的业务区分度以及过期时间区分度，并且以全局常量的方式提供，采取集中化管理的方式，禁止采用魔术变量的方式指定CacheName。</span><br></pre></td></tr></table></figure><h5 id="（二）常用注解"><a href="#（二）常用注解" class="headerlink" title="（二）常用注解"></a>（二）常用注解</h5><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、配置注解</span><br><span class="line">（<span class="number">1</span>）EnableCaching</span><br><span class="line">标注于SpringBoot应用启动类上，添加此注解表示开启Spring <span class="keyword">Cache</span>缓存；移除表示关闭缓存。如果在全局配置文件中添加如下配置，即使在启动类上标注EnableCaching注解，Spring <span class="keyword">Cache</span>缓存然后是关闭状态。</span><br><span class="line">spring:</span><br><span class="line">  <span class="keyword">cache</span>:</span><br><span class="line">    <span class="keyword">type</span>: <span class="literal">none</span></span><br><span class="line">如果应用中自定义独立于Spring容器的缓存，则不受此配置影响。</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）CacheConfig</span><br><span class="line">标注于类上，更具体的说是标注于业务服务类上。统一配置如下参数信息：</span><br><span class="line">在类上统一进行配置，类下的方法自动继承相应的配置。</span><br></pre></td></tr></table></figure><p><img src="https://pic1.zhimg.com/80/v2-7d7a724657b10e247c3c2039568cb2d0_720w.webp" alt="img"></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、缓存注解</span><br><span class="line">（<span class="number">1</span>）Cacheable</span><br><span class="line">添加缓存的核心注解，分两种情况：一是对应<span class="built_in">key</span>值未有缓存数据，先执行方法，然后根据condition和<span class="keyword">unless</span>条件决定是否添加缓存；二是对应<span class="built_in">key</span>值已有缓存，不执行方法体，直接返回数据。</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-6e8d2db944cc5c886e1051c4149f460e_720w.webp" alt="img"></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">2</span>）CachePut</span><br><span class="line">更新缓存注解。不管对应<span class="built_in">key</span>值是否有缓存数据，都执行。</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-121bf58fd2885ec9acdc07e58e5b8b23_720w.webp" alt="img"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">3</span>）<span class="keyword">CacheEvict</span></span><br><span class="line"><span class="keyword"></span>主动清除缓存注解。</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-80632bc1025e0cd284be8e256a81911b_720w.webp" alt="img"></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>、KeyGenerator</span><br><span class="line">默认情况下使用SimpleKeyGenerator键值生成器，当不指定<span class="built_in">key</span>值时，根据生成器规则，将方法参数转化为缓存<span class="built_in">Key</span>值。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCache </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO</title>
      <link href="/2023/07/06/32.MinIO/"/>
      <url>/2023/07/06/32.MinIO/</url>
      
        <content type="html"><![CDATA[<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java中锁的实现方式有两种：synchronized关键字和并发包中的锁类。</span><br><span class="line"><span class="number">1.</span>synchronized </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">lock</span>.<span class="keyword">lock</span>()</span><br><span class="line"><span class="keyword">lock</span>.unlock()</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">帮助MySQL高效获取数据的数据结构，以空间换时间，数据库在未添加索引进行查询的时候默认是进行全文搜索。</span><br><span class="line">主键索引</span><br><span class="line">唯一索引</span><br><span class="line">复合索引(联合)（<span class="number">1.</span>满足最左前缀原则<span class="number">2.</span>字段全部达到复合索引中的字段时,可以动态调整字段顺序，满足最前左缀）</span><br><span class="line"></span><br><span class="line">索引的数据结构:</span><br><span class="line">MySQL索引使用的数据结构主要有BTree索引和hash索引。</span><br><span class="line">对于hash索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景建议选择BTree索引。</span><br><span class="line"></span><br><span class="line">在上面的abc_innodb表中的组合索引查询时，如果我们查询的结果只需要a、b、c这三个字段，那我们使用这个idx<span class="constructor">_index(<span class="params">a</span>，<span class="params">b</span>，<span class="params">c</span>)</span>组合索引查询到叶子节点时就可以直接返回了，不需要再次回表查询，这种情况就是==覆盖索引</span><br><span class="line"></span><br><span class="line">在InnoDB的存储引擎中，使用辅助索引查询的时候，因为辅助索引叶子节点保存的数据不是当前数据记录，而是当前数据记录的主键索引。如果需要获取当前记录完整的数据，就必须要再次根据主键从主键索引中继续检索查询，这个过程我们称之为回表查询。</span><br></pre></td></tr></table></figure><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MyISAM</span></span><br><span class="line"><span class="attribute">InnoDB</span></span><br></pre></td></tr></table></figure><h1 id="缓存穿透、击穿、雪崩"><a href="#缓存穿透、击穿、雪崩" class="headerlink" title="缓存穿透、击穿、雪崩"></a>缓存穿透、击穿、雪崩</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">什么是缓存穿透？</span><br><span class="line">我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的<span class="type">key</span>是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</span><br><span class="line">分析：</span><br><span class="line">关键在于在Redis查不到<span class="type">key</span>值，这和缓存击穿有根本的区别，区别在于缓存穿透的情况是传进来的<span class="type">key</span>在Redis中是不存在的。假如有黑客传进大量的不存在的<span class="type">key</span>，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的<span class="type">key</span>就直接返回错误提示，要对调用方保持这种“不信任”的心态。、</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、把无效的Key存进Redis中。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=<span class="string">&quot;null&quot;</span>，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</span><br><span class="line"><span class="number">2</span>、使用布隆过滤器。布隆过滤器的作用是某个 <span class="type">key</span> 不存在，那么就一定不存在，它说某个 <span class="type">key</span> 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 <span class="type">key</span> 是否存在，如果不存在就直接返回。</span><br><span class="line"></span><br><span class="line">什么是缓存击穿？</span><br><span class="line">缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</span><br><span class="line">分析：关键在于某个热点的<span class="type">key</span>失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点<span class="type">key</span>不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、上面说过了，如果业务允许的话，对于热点的<span class="type">key</span>可以设置永不过期的<span class="type">key</span>。</span><br><span class="line"><span class="number">2</span>、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。</span><br><span class="line"></span><br><span class="line">什么是缓存雪崩？</span><br><span class="line">当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</span><br><span class="line">分析：造成缓存雪崩的关键在于在同一时间大规模的<span class="type">key</span>失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、在原有的失效时间上加上一个随机值，比如<span class="number">1</span><span class="number">-5</span>分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</span><br><span class="line">如果真的发生了缓存雪崩，有没有什么兜底的措施？</span><br><span class="line"><span class="number">2</span>、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</span><br><span class="line"><span class="number">3</span>、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</span><br><span class="line"><span class="number">4</span>、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</span><br></pre></td></tr></table></figure><h2 id="springbuffer，springbuilder"><a href="#springbuffer，springbuilder" class="headerlink" title="springbuffer，springbuilder"></a>springbuffer，springbuilder</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="built_in">StringBuffer</span> 与 StringBuilder 中的方法和功能完全是等价的。</span><br><span class="line"><span class="number">2</span>、只是<span class="built_in">StringBuffer</span> 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而StringBuilder 没有这个修饰，可以被认为是线程不安全的。</span><br><span class="line"><span class="number">3</span>、在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全，而<span class="built_in">StringBuffer</span>则每次都需要判断锁，效率相对更低</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">负载均衡策略：</span><br><span class="line">轮询默认方式</span><br><span class="line"><span class="symbol">weight</span>权重方式</span><br><span class="line"><span class="symbol">ip_hash</span>依据<span class="built_in">ip</span>分配方式</span><br><span class="line"><span class="symbol">least_conn</span>最少连接方式</span><br><span class="line"><span class="symbol">fair</span>（第三方）响应时间方式</span><br><span class="line"><span class="symbol">url_hash</span>（第三方）依据URL分配方式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MinIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ApacheKafka</title>
      <link href="/2023/07/06/31.ApacheKafka/"/>
      <url>/2023/07/06/31.ApacheKafka/</url>
      
        <content type="html"><![CDATA[<h1 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>临时变量</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>全局变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作流Activiti</title>
      <link href="/2023/04/17/30.%E5%B7%A5%E4%BD%9C%E6%B5%81Activiti/"/>
      <url>/2023/04/17/30.%E5%B7%A5%E4%BD%9C%E6%B5%81Activiti/</url>
      
        <content type="html"><![CDATA[<h1 id="工作流Activiti"><a href="#工作流Activiti" class="headerlink" title="工作流Activiti"></a>工作流Activiti</h1><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>临时变量</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>全局变量</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Activiti </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activiti </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2023/04/14/29.IO%E6%B5%81/"/>
      <url>/2023/04/14/29.IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">WebService（SOAP）与Http接口（API）的区别:</span><br><span class="line">soap请求是http post的一个专用版本，遵循一种特殊的<span class="type">xml</span>消息格式content-<span class="keyword">type</span>设置为: <span class="type">text</span>/<span class="type">xml</span>任何数据都可以<span class="type">xml</span>化。</span><br><span class="line">大多数对外接口会实现web service方法而不是http方法。</span><br><span class="line">httpservice通过post和<span class="keyword">get</span>得到你想要的东西，进行<span class="type">xml</span>解析，速度可能会有所降低。</span><br><span class="line">webservice就是使用soap协议得到你想要的东西，相比httpservice能处理些更加复杂的数据类型。</span><br><span class="line">http协议传输的都是字符串了，webservice则是包装成了更复杂的对象。</span><br><span class="line">webservice走http协议和<span class="number">80</span>端口。而你说的api，用的协议和端口，是根据开发人员定义的。</span><br><span class="line"></span><br><span class="line">string为啥用final修饰，是线程安全的吗？</span><br><span class="line">* string是final修饰的类，是不可变的，所以是线程安全的。</span><br><span class="line">String类不可被继承。String类的不可变性，才能使得JVM可以实现字符串常量池；字符串常量池可以在程序运行时节约很多内存空间，因为不同的字符串变量指向相同的字面量时，都是指向字符串常量池中的同一个对象。这样一方面能够节约内存，另一方面也提升了性能。字符串对象在多线程环境下是线程安全的。如果String类是可变的，那么会引起很严重的安全问题。</span><br><span class="line"></span><br><span class="line">stringbuffer，string,stringbulider 区别？</span><br><span class="line">* 运行速度和线程安全</span><br><span class="line"></span><br><span class="line">synchronized和<span class="keyword">lock</span>区别？</span><br><span class="line">* Synchronized 是Java 并发编程中很重要的关键字</span><br><span class="line">Syncronized 的目的是一次只允许一个线程进入由他修饰的代码段，从而允许他们进行自我保护。Synchronized 很像生活中的锁例子，进入由Synchronized 保护的代码区首先需要获取 Synchronized 这把锁，其他线程想要执行必须进行等待。Synchronized 锁住的代码区域执行完成后需要把锁归还，也就是释放锁，这样才能够让其他线程使用。</span><br><span class="line">* <span class="keyword">Lock</span> 是 Java并发编程中很重要的一个接口，</span><br><span class="line"><span class="keyword">Lock</span>需要手动加锁和手动解锁，一般通过 <span class="keyword">lock</span>.<span class="keyword">lock</span>() 方法来进行加锁， 通过 <span class="keyword">lock</span>.unlock() 方法进行解锁。</span><br><span class="line"></span><br><span class="line">java有什么方法进入阻塞状态？</span><br><span class="line">* 线程阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪)</span><br><span class="line">sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态</span><br><span class="line">wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 <span class="keyword">notify</span>() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 <span class="keyword">notify</span>() 被调用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">notify</span>()方法、notifyAll()方法和wait()方法</span><br><span class="line">- wait()、<span class="keyword">notify</span>()和notifyAll()方法使类<span class="keyword">Object</span>中定义的方法</span><br><span class="line">- wait()</span><br><span class="line">try&#123;</span><br><span class="line">        wait();</span><br><span class="line">    &#125;catch(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">- <span class="keyword">notify</span>()</span><br><span class="line">使用某个对象的<span class="keyword">notify</span>()方法时，将从该对象的等待集合中选择一个等待的线程唤醒，唤醒的将从集合中删除。</span><br><span class="line">- notifyAll()</span><br><span class="line">会将所有在等待集合中的线程唤醒，但由于所有的被唤醒的线程仍然要去争用synchronized锁，而synchronized锁具有排他性，最终只有一个线程获得该锁，进行执行状态，其他线程仍要继续等待。</span><br><span class="line"></span><br><span class="line"><span class="keyword">lock</span>加锁过程</span><br><span class="line">一种是关键字：synchronized： 是java底层支持的。</span><br><span class="line">一种是concurrent包下的<span class="keyword">lock</span>锁： 是jdk实现。</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>怎么保证可见性?</span><br><span class="line"><span class="keyword">volatile</span>关键字能够保证可见性和有序性</span><br><span class="line"></span><br><span class="line">垃圾收集器有哪些？</span><br><span class="line">G1 垃圾回收器，是一种高吞吐量的垃圾回收器。</span><br><span class="line">CMS 垃圾回收器，并发标记清除垃圾回收器。</span><br><span class="line">垃圾回收算法: </span><br><span class="line">标记清除</span><br><span class="line">* 是一种先标记，后清除的算法，在第一次扫描的时候先标记出所有需要清理的内存，将所有需要回收的内存都标记过后，一次性清理掉。这种算法简单但是效率低，而且内存碎片化严重。</span><br><span class="line">复制算法</span><br><span class="line">* 把内存分成两部分，在平时使用的时候只用其中的固定一份，在当需要进行 GC 的时候，把存活的对象复制到另一部分中，然后将已经使用的内存全部清理掉。</span><br><span class="line">标记整理算法</span><br><span class="line">* 标记阶段是标记清除算法一样，先标记出需要回收的部分，不过清除阶段不是直接清除，而是把存活的对象往内存的一端进行移动，然后清除剩下的部分。</span><br><span class="line">分代回收算法</span><br><span class="line">* 分代回收算法是目前使用较多的一种算法，这个不是一个新的算法，只是将内存进行的划分，不同区域的内存使用不同的算法。根据对象的存活时间将内存的划分为新生代和老年代，其中新生代包含 Eden 区和 S0，S1。在新生代中使用是复制算法，在进行对象内存分配的时候只会使用 Eden 和 S0 区，当发生 GC 的时候，会将存活的对象复制到 S1 区，然后循环往复进行复制。当某个对象在进行了 <span class="number">15</span> 次GC 后依旧存活，那这个对象就会进入老年代。老年代因为每次回收的对象都会比较少，因此使用的是标记整理算法。</span><br><span class="line"></span><br><span class="line">双亲委派好处？打破？</span><br><span class="line">如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</span><br><span class="line">如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</span><br><span class="line">如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</span><br><span class="line">-避免类的重复加载</span><br><span class="line">-保护程序安全，防止核心API被随意篡改</span><br><span class="line"></span><br><span class="line">fullgc怎么回事？</span><br><span class="line"><span class="number">1</span>、项目启动时加载了比较多或者比较大的对象，导致空间不够，频繁扩容；</span><br><span class="line"><span class="number">2</span>、初始化空间太小，不够用，所以进行频繁扩容。</span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> a&gt;<span class="number">1</span> <span class="keyword">and</span> b=<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> c怎么建索引？</span><br><span class="line">排序字段进行索引的创建</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">简单说一下对SpringBoot的理解</span><br><span class="line">SpringBoot是基于 Spring 开发的一种轻量级的全新框架，不仅继承了 Spring 框架原有的优秀特性，而且还通过简化配置来进一步简化了 Spring 应用的整个搭建和开发过程。 通过 Spring Boot，可以轻松地创建独立的，基于生产级别的基于 Spring 的应用程序。</span><br><span class="line"></span><br><span class="line">项目里面用到了哪些注解</span><br><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@RunWith</span>(SpringRunner.class) <span class="variable">@SpringBootTest</span></span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line"><span class="variable">@Autowired</span></span><br><span class="line"><span class="variable">@RestController</span><span class="operator">=</span>Controller<span class="operator">+</span>ResponseBody</span><br><span class="line"><span class="variable">@ReqeustMapping</span></span><br><span class="line"><span class="variable">@RequestParam</span> <span class="variable">@PathVariable</span><span class="variable">@RequestBody</span></span><br><span class="line"><span class="operator">*</span> <span class="variable">@RequestBody</span>主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；而最常用的使用请求体传参的无疑是POST请求了，所以使用<span class="variable">@RequestBody</span>接收数据时，一般都用POST方式进行提交。在后端的同一个接收方法里，<span class="variable">@RequestBody</span>与<span class="variable">@RequestParam</span>()可以同时使用，<span class="variable">@RequestBody</span>最多只能有一个，而<span class="variable">@RequestParam</span>()可以有多个。</span><br><span class="line"></span><br><span class="line">简单说一下项目里面的Redis缓存</span><br><span class="line">redis作为缓存的作用就是减少对数据库的访问压力，当我们访问一个数据的时候，首先我们从redis中查看是否有该数据，如果没有，则从数据库中读取，将从数据库中读取的数据存放到缓存中，下次再访问同样的数据的是，还是先判断redis中是否存在该数据，如果有，则从缓存中读取，不访问数据库</span><br><span class="line"></span><br><span class="line">JDK和JRE的区别</span><br><span class="line">JDK顾名思义是java开发工具包（JRE和开发工具）</span><br><span class="line">JRE顾名思义是java运行时环境（JVM和核心类库）</span><br><span class="line"></span><br><span class="line">说一下Java的<span class="number">8</span>种基本数据类型</span><br><span class="line">java八种基本数据类型分为四类八种，四类分别为整型、浮点型、布尔型、字符型；八种分别为byte、short、<span class="type">int</span>、long、<span class="type">float</span>、<span class="keyword">double</span>、<span class="type">boolean</span>、<span class="type">char</span>；</span><br><span class="line"></span><br><span class="line">创建线程有那哪些方式</span><br><span class="line">继承Thread类创建线程</span><br><span class="line">实现Runnable接口创建线程</span><br><span class="line"></span><br><span class="line">Session和Cookie的区别</span><br><span class="line">cookie数据保存在客户端，session数据保存在服务端。</span><br><span class="line">客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</span><br><span class="line"></span><br><span class="line"><span class="keyword">Get</span>请求和Post请求的区别</span><br><span class="line">http请求方式有<span class="keyword">get</span>、post、put、<span class="keyword">delete</span>等多种</span><br><span class="line"><span class="number">1</span>、<span class="keyword">GET</span>请求一般用去请求获取数据，</span><br><span class="line">POST一般作为发送数据到后台时使用</span><br><span class="line"><span class="number">2</span>、<span class="keyword">GET</span>请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的</span><br><span class="line">POST请求传递参数放在Request body中，不会在url中显示，比<span class="keyword">GET</span>要安全，且参数长度无限制</span><br><span class="line"><span class="number">3</span>、<span class="keyword">GET</span>请求刷新浏览器或回退时没有影响</span><br><span class="line">POST回退时会重新提交数据请求</span><br><span class="line"><span class="number">4</span>、<span class="keyword">GET</span> 请求可被缓存</span><br><span class="line">POST 请求不会被缓存</span><br><span class="line"><span class="number">5</span>、<span class="keyword">GET</span> 请求保留在浏览器历史记录中</span><br><span class="line">POST 请求不会保留在浏览器历史记录中</span><br><span class="line"><span class="number">6</span>、<span class="keyword">GET</span> 请求可被收藏为书签</span><br><span class="line">POST 不能被收藏为书签</span><br><span class="line"><span class="number">7</span>、<span class="keyword">GET</span>请求只能进行url编码（application<span class="operator">/</span>x<span class="operator">-</span>www<span class="operator">-</span>form<span class="operator">-</span>urlencoded）</span><br><span class="line">POST支持多种编码方式（application<span class="operator">/</span>x<span class="operator">-</span>www<span class="operator">-</span>form<span class="operator">-</span>urlencoded 或 multipart<span class="operator">/</span>form<span class="operator">-</span>data。为二进制数据使用多重编码。）</span><br><span class="line"><span class="number">8</span>、<span class="keyword">GET</span>请求比较常见的方式是通过url地址栏请求</span><br><span class="line">POST最常见是通过form表单发送数据请求</span><br><span class="line"></span><br><span class="line">集合List ，<span class="keyword">Set</span>，Map</span><br><span class="line">List和<span class="keyword">Set</span>是存储单列数据的集合，Map是存储键值对这样的双列数据的集合；</span><br><span class="line">List中存储的数据是有顺序的，并且值允许重复；</span><br><span class="line">Map中存储的数据是无序的，它的键是不允许重复的，但是值是允许重复的；</span><br><span class="line"><span class="keyword">Set</span>中存储的数据是无顺序的，并且不允许重复，但元素在集合中的位置是由元素的hashcode决定，即位置是固定的（<span class="keyword">Set</span>集合是根据hashcode来进行数据存储的，所以位置是固定的，但是这个位置不是用户可以控制的，所以对于用户来说<span class="keyword">set</span>中的元素还是无序的）</span><br><span class="line">List接口有三个实现类：</span><br><span class="line"><span class="number">1.1</span> LinkedList</span><br><span class="line">基于链表实现，链表内存是散列的，增删快，查找慢；</span><br><span class="line"><span class="number">1.2</span> ArrayList</span><br><span class="line">基于数组实现，非线程安全，效率高，增删慢，查找快；</span><br><span class="line"><span class="number">1.3</span> Vector</span><br><span class="line">基于数组实现，线程安全，效率低，增删慢，查找慢；</span><br><span class="line"><span class="keyword">Set</span>接口有两个实现类：</span><br><span class="line"><span class="number">3.1</span> HashSet</span><br><span class="line">底层是由 Hash Map 实现，不允许集合中有重复的值，使用该方式时需要重写 <span class="keyword">equals</span>()和 hash Code()方法；</span><br><span class="line"><span class="number">3.2</span> LinkedHashSet</span><br><span class="line">继承于 HashSet，同时又基于 LinkedHashMap 来进行实现，底层使用的是 LinkedHashMap</span><br><span class="line">Map接口有四个实现类：</span><br><span class="line"><span class="number">2.1</span> HashMap</span><br><span class="line">基于 hash 表的 Map 接口实现，非线程安全，高效，支持 <span class="keyword">null</span> 值和 <span class="keyword">null</span></span><br><span class="line">键；</span><br><span class="line"><span class="number">2.2</span> HashTable</span><br><span class="line">线程安全，低效，不支持 <span class="keyword">null</span> 值和 <span class="keyword">null</span> 键；</span><br><span class="line"><span class="number">2.3</span> LinkedHashMap</span><br><span class="line">是 HashMap 的一个子类，保存了记录的插入顺序；</span><br><span class="line"><span class="number">2.4</span> SortMap 接口</span><br><span class="line">TreeMap，能够把它保存的记录根据键排序，默认是键值的升序排序</span><br><span class="line"></span><br><span class="line">HashMap 是线程不安全的,HashMap 是一个接口,是 Map的一个子接口,是将键映射到值得对象,不允许键值重复,允许空键和空值;由于非线程安全, HashMap的效率要较 HashTable 的效率高一些.</span><br><span class="line">HashTable 是线程安全的一个集合,不允许 <span class="keyword">null</span> 值作为一个 key 值或者 <span class="keyword">Value</span> 值;</span><br><span class="line">HashTable 是 sychronize(同步化),多个线程访问时不需要自己为它的方法实现同步,而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步;</span><br><span class="line"></span><br><span class="line">左连接，右连接，内连接（以小表驱动大表）</span><br><span class="line">区别：左连接返回包括左表中的所有记录和右表中连接字段相等的记录；右连接返回包括右表中的所有记录和左表中连接字段相等的记录；内连接只返回两个表中连接字段相等的行；全外连接返回左右表中所有的记录和左右表中连接字段相等的记录。</span><br><span class="line"></span><br><span class="line">对反射的理解</span><br><span class="line">反射机制（Reflection）是指动态获取类信息、动态调用类方法的功能</span><br><span class="line"></span><br><span class="line">说一下SpringMvc的工作流程</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210306223048434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MzYwMTM1OQ==,size_16,color_FFFFFF,t_70" alt="img"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>几个字节，<span class="type">int</span>几个字节</span><br><span class="line"><span class="number">8</span>，<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>占用<span class="number">8</span>个字节（<span class="number">64</span>位），可以存储双精度浮点数。</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>占用<span class="number">4</span>个字节（<span class="number">32</span>位），可以存储整数。</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span>和<span class="type">int</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="type">integer</span> a <span class="operator">=</span> <span class="number">125</span>会发生什么</span><br><span class="line"></span><br><span class="line"><span class="keyword">equals</span>重写还需要做什么</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span>和<span class="keyword">equals</span>的区别</span><br><span class="line"></span><br><span class="line">jvm常用参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>一个对象，整个生命周期是什么样子的</span><br><span class="line"></span><br><span class="line">G1垃圾回收器</span><br><span class="line"></span><br><span class="line">并发编程用的哪些容器</span><br><span class="line"></span><br><span class="line">countdownlanuch有任务失败了，怎么办</span><br><span class="line"></span><br><span class="line">tcp和udp</span><br><span class="line"></span><br><span class="line">tcp限流怎么做</span><br><span class="line"></span><br><span class="line">tcp客户端没有找到服务端，那么他的状态机是什么</span><br><span class="line"></span><br><span class="line">拆包粘包</span><br><span class="line"></span><br><span class="line">springboot轻便的原因</span><br><span class="line"></span><br><span class="line">单例模式怎么实现</span><br><span class="line"></span><br><span class="line">指令重排序依赖于什么情况</span><br><span class="line"></span><br><span class="line">hashmap线程安全吗，在什么时候会线程不安全</span><br><span class="line"></span><br><span class="line">hashmap怎么扩容的</span><br><span class="line"></span><br><span class="line">慢<span class="keyword">sql</span>优化思路</span><br><span class="line"></span><br><span class="line">对<span class="number">500</span>w数据量的表更新，没加索引，会发生什么</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">java ee/se/me区别?</span><br><span class="line"></span><br><span class="line">jdk jre区别?</span><br><span class="line"></span><br><span class="line">java常用的命令有哪些?</span><br><span class="line"></span><br><span class="line">java的数据类型以及应用场景</span><br><span class="line"></span><br><span class="line">java的语法</span><br><span class="line"></span><br><span class="line">java泛型</span><br><span class="line">Java 泛型（generics）是 JDK <span class="number">5</span> 中引入的一个新特性，泛型的本质是参数化类型，强制类型转换</span><br><span class="line"></span><br><span class="line">说一下stream</span><br><span class="line"></span><br><span class="line">说一下马文?没用过这时啥?后来才了解是梅文maven,说一下常用命令</span><br><span class="line">maven clean：对项目进行清理，删除target目录下编译的内容</span><br><span class="line">maven compile：编译项目源代码</span><br><span class="line">maven test：对项目进行运行测试</span><br><span class="line">maven packet：打包文件并存放到项目的target目录下，打包好的文件通常都是编译后的<span class="keyword">class</span>文件</span><br><span class="line"><span class="symbol">maven</span> <span class="symbol">install</span>：在本地仓库生成仓库的安装包，可供其他项目引用，同时打包后的文件放到项目的<span class="symbol">target</span>目录下</span><br><span class="line"></span><br><span class="line"><span class="symbol">maven</span>怎么解决版本冲突</span><br><span class="line"></span><br><span class="line"><span class="symbol">maven</span>怎么统一管理版本号</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span>的常用命令</span><br><span class="line"></span><br><span class="line">怎么解决合并冲突</span><br><span class="line"></span><br><span class="line">项目帖子的字段如何设计的?内容字段设计的类型是什么?</span><br><span class="line"></span><br><span class="line">帖子内容如果支持图片,你会怎么设计?</span><br><span class="line"></span><br><span class="line"><span class="symbol">mybatis</span> <span class="symbol">plus</span>的使用以及优点?</span><br><span class="line"></span><br><span class="line">让你实现一下<span class="symbol">mybatis</span> <span class="symbol">plus</span>你会怎么做,比如反射?</span><br><span class="line"></span><br><span class="line"><span class="symbol">spring</span>和<span class="symbol">springboot</span>的区别</span><br><span class="line"></span><br><span class="line"><span class="symbol">springboot</span>怎么做到的自动装配</span><br><span class="line"></span><br><span class="line"><span class="symbol">spring</span>和<span class="symbol">springboot</span>项目部署有什么不同</span><br><span class="line"></span><br><span class="line">怎么部署一个<span class="symbol">java</span>项目上线</span><br><span class="line"></span><br><span class="line"><span class="symbol">docker</span>常用命令</span><br><span class="line"></span><br><span class="line"><span class="symbol">docker</span>集群怎么统一管理</span><br><span class="line"></span><br><span class="line"><span class="symbol">dockerfile</span>相关</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">怎么用的Oss</span><br><span class="line"></span><br><span class="line">项目中用到了那些Java类</span><br><span class="line"></span><br><span class="line">用了哪些集合</span><br><span class="line"></span><br><span class="line">HashMap的<span class="built_in">Key</span>&#x27;Value讲讲。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Key</span>为什么不重复</span><br><span class="line"></span><br><span class="line">能讲讲链表到树怎么实现的（不会）</span><br><span class="line"></span><br><span class="line">ArrayList怎么遍历的</span><br><span class="line"></span><br><span class="line">Stream流你怎么用的</span><br><span class="line"></span><br><span class="line">Srteam常用方法</span><br><span class="line"></span><br><span class="line">创建多线程的方式</span><br><span class="line">新建状态</span><br><span class="line">就绪状态</span><br><span class="line">运行状态</span><br><span class="line">阻塞状态</span><br><span class="line">死亡状态</span><br><span class="line"></span><br><span class="line">线程池创建用的那个类</span><br><span class="line">ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">线程阻塞<span class="built_in">wait</span>与<span class="built_in">sleep</span>的区别：</span><br><span class="line">字面意思理解为，<span class="built_in">wait</span>为等待，直到被唤醒；而<span class="built_in">sleep</span>为睡眠，直到设定的时间，所以<span class="built_in">wait</span>需要手动唤醒，而<span class="built_in">sleep</span>不需要。</span><br><span class="line"></span><br><span class="line">io使用过吗？</span><br><span class="line"></span><br><span class="line">Spring用到了哪些注解</span><br><span class="line"></span><br><span class="line">Mybatisplus你是自己写sql吗？</span><br><span class="line"></span><br><span class="line">介绍一下MybatisPlus你用了那些方法。</span><br><span class="line"></span><br><span class="line">查询的时候List能用quryWapper吗？</span><br><span class="line"></span><br><span class="line">Mybatisplus兼容jdk8的用过吗？（没有）</span><br><span class="line"></span><br><span class="line">＃&#123;&#125;和$&#123;&#125;讲讲</span><br><span class="line"></span><br><span class="line">mybatis的注解用过吗</span><br><span class="line"></span><br><span class="line">Aop了解吗？</span><br><span class="line"></span><br><span class="line">自动装配能讲讲吗？</span><br><span class="line"></span><br><span class="line">Spring怎么管理bean</span><br><span class="line"></span><br><span class="line">redis有用到锁吗？</span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">为什么走<span class="keyword">Java路线，Java与C++相比，优势在哪？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说hashCode方法？</span><br><span class="line"></span><br><span class="line">说说你了解哪些哈希集合，详细说说HashMap的实现和扩容机制及扩容可能会出现什么问题？</span><br><span class="line"></span><br><span class="line">详细说说<span class="keyword">Java里面的异常机制，以及常见的运行时异常和必检异常</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说<span class="keyword">syncronized关键字和用法，底层实现原理？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">抽象类和接口的区别？接口的设计在<span class="keyword">JDK1.8之前和之后有什么变化？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说线程创建的方式，你用过哪些？重点说说线程池中的三大方法和七大参数四大拒绝策略？</span><br><span class="line"></span><br><span class="line">线程池中线程是不是越多越好？线程创建需要耗费哪些资源？针对CPU密集型和IO密集型线程数如何设置？</span><br><span class="line"></span><br><span class="line">说说<span class="keyword">JVM中的内存区域？从GC的角度堆被如何划分了？每个区域采用何种垃圾回收算法？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">新生代中又分为那几块区域？说说轻GC（MinorGC）的基本过程</span><br><span class="line"></span><br><span class="line">说说TCP与UDP的区别，TCP数据包的结构，包含哪些字段？TCP的拥塞控制过程？</span><br><span class="line"></span><br><span class="line">说说Redis的基本数据类型，你在项目中是使用的是哪些，为什么这么用？</span><br><span class="line"></span><br><span class="line">讲讲Spring事务管理，如何使用？</span><br><span class="line"></span><br><span class="line">详细说说ACID是什么，如何保证？和 MySQL事务隔离级别及能解决哪些问题？</span><br><span class="line"></span><br><span class="line">MySQL索引底层是什么？为什么采用<span class="keyword">B+树？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">MySQL索引什么时候失效？结合<span class="keyword">B+树说说为什么会失效？</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">说说SpringCloud的基本组件？</span><br><span class="line"></span><br><span class="line">索引底层的数据结构了解吗</span><br><span class="line"></span><br><span class="line"><span class="keyword">b+树的特性，除了访问快还有哪些</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">一步步分析为什么<span class="keyword">B+树适合作为索引的结构 </span>以及索引原理 </span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">一个url请求在网络中会经历什么</span><br><span class="line">* <span class="number">1.</span>输入url <span class="number">2.</span>DNS域名解析 <span class="number">3.</span>建立TCP连接 <span class="number">4.</span>发送HTTPRequest <span class="number">5.</span>Web服务器 <span class="number">6.</span>应用服务器Servlet处理请 求 <span class="number">7.</span>关闭TCP连接 <span class="number">8.</span>渲染相应页面</span><br><span class="line"></span><br><span class="line">gc判断对象可回收的方法</span><br><span class="line">* <span class="number">1.</span>引用计数法：每个对象有一个引用计数属性，新增一个引用时计数器+<span class="number">1</span>，引用释放时计算器 <span class="number">-1</span>，计数为<span class="number">0</span>时可以回收。<span class="number">2.</span>可达性分析：从GC Roots开始向下收索，搜索走过的路径成为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，那么虚拟机就判断是可回收对象。</span><br><span class="line"></span><br><span class="line">gc的过程是什么，<span class="keyword">new</span><span class="type"></span>一个新的对象，但是新生代和老生代都已经满了</span><br><span class="line">* 新生代 GC（Minor GC）:<span class="type"></span>指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</span><br><span class="line">老年代 GC（Major GC/Full GC）:<span class="type"></span>指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 <span class="number">10</span> 倍以上。</span><br><span class="line"></span><br><span class="line">线程池的类型，线程池的参数</span><br><span class="line">*线程池的类型:<span class="type"></span></span><br><span class="line"><span class="number">1</span>、<span class="keyword">new</span><span class="type">CachedThreadPool</span></span><br><span class="line">创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span><br><span class="line">这种类型的线程池特点是：</span><br><span class="line">工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</span><br><span class="line">如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为<span class="number">1</span>分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</span><br><span class="line">在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">new</span><span class="type">FixedThreadPool</span></span><br><span class="line">创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</span><br><span class="line">FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</span><br><span class="line"><span class="number">3</span>、<span class="keyword">new</span><span class="type">SingleThreadExecutor</span></span><br><span class="line">创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</span><br><span class="line"><span class="number">4</span>、<span class="keyword">new</span><span class="type">ScheduleThreadPool</span></span><br><span class="line">创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</span><br><span class="line"><span class="number">5</span>、<span class="keyword">new</span><span class="type">SingleThreadScheduledExecutor</span></span><br><span class="line">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行<span class="number">1</span>个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。</span><br><span class="line">*线程池的参数: <span class="type"></span></span><br><span class="line">corePoolSize：核心线程数</span><br><span class="line">maximumPoolSize：最大线程数</span><br><span class="line">keepAliveTime：空闲线程存活时间</span><br><span class="line">unit：时间单位</span><br><span class="line">workQueue：工作队列</span><br><span class="line">threadFactory：线程工厂</span><br><span class="line">handler：拒绝策略</span><br><span class="line"></span><br><span class="line">mysql的索引了解吗，索引的原则有哪些，索引越多越好吗?</span><br><span class="line">* 索引是帮助MySQL高效获取数据的数据结构（以空间换时间）</span><br><span class="line">建立索引的原则: <span class="type"></span></span><br><span class="line"><span class="number">1.</span>选择唯一性索引 <span class="number">2.</span>为经常需要排序、分组和联合操作的字段建立索引 <span class="number">3.</span>为常作为查询条件的字段建立索引 <span class="number">4.</span></span><br><span class="line">太多索引会占用很多的索引表空间，甚至比存储一条记录更多。导致更新操作速度慢 <span class="number">5.</span>尽量使用数据量少的索引 <span class="number">6.</span>尽量使用前缀来索引 <span class="number">7.</span>删除不再使用或者很少使用的索引 <span class="number">8.</span>最左前缀匹配原则，非常重要的原则 <span class="number">9.</span>=和<span class="keyword">in</span>可以乱序 <span class="number">10.</span>尽量选择区分度高的列作为索引 <span class="number">11.</span>索引列不能参与计算，保持列“干净” <span class="number">12.</span>尽量的扩展索引，不要新建索引 <span class="number">13.</span>当单个索引字段查询数据很多，区分度都不是很大时，则需要考虑建立联合索引来提高查询效率</span><br><span class="line"></span><br><span class="line">spring ioc和aop是什么，简单介绍一下</span><br><span class="line">IoC，意为控制反转，AOP，意为面向切面编程。</span><br><span class="line">Spring核心容器的主要组件是Bean工厂（BeanFactory），Bean工厂使用控制反转（IoC）模式来降低程序代码之间的耦合度，并提供了面向切面编程（AOP）的实现。</span><br><span class="line"></span><br><span class="line">说一下springclound</span><br><span class="line">分布式微服务架构的一站式解决方案，它提供了很多组件用来解决了分布式架构所带来的一些问题。</span><br><span class="line"></span><br><span class="line">说一下redis的使用场景</span><br><span class="line">缓存、排行榜、计数器、分布式会话、分布式锁、社交网络、最新列表、消息系统</span><br><span class="line"></span><br><span class="line">redis如何于数据库保持数据一致性</span><br><span class="line">* 在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</span><br><span class="line">第一种方案：采用延时双删策略+缓存超时设置  在写库前后都进行redis.del(key)操作，并且设定合理超时时间。</span><br><span class="line">第二种方案：异步更新缓存(基于订阅binlog的同步机制)</span><br><span class="line"></span><br><span class="line">线程池的执行流程</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230221173916811.png" alt="image-20230221173916811" style="zoom:60%;" /><h5 id="用户注册使用的SpringSecurity和Jwt-讲一讲流程。token过期你怎么处理"><a href="#用户注册使用的SpringSecurity和Jwt-讲一讲流程。token过期你怎么处理" class="headerlink" title="用户注册使用的SpringSecurity和Jwt@讲一讲流程。token过期你怎么处理"></a>用户注册使用的SpringSecurity和Jwt@讲一讲流程。token过期你怎么处理</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">用户注册过程使用SpringSecurity和Jwt可以分为以下步骤：</span><br><span class="line"></span><br><span class="line">用户提交注册表单后，后端接收到请求，进行表单验证，如果验证通过则将用户信息保存到数据库中。</span><br><span class="line"></span><br><span class="line">用户登录时，后端接收到登录请求，验证用户名和密码是否匹配，如果匹配则生成一个Jwt token，将其作为响应返回给客户端。</span><br><span class="line"></span><br><span class="line">客户端在以后的请求中，将Jwt token添加到请求头中，后端通过Jwt验证token的合法性，并获取其中的用户信息，进行相应操作。</span><br><span class="line"></span><br><span class="line">具体实现中，可以使用SpringSecurity提供的JwtAuthenticationFilter拦截请求，验证token的合法性，并将用户信息保存到SpringSecurity的上下文中，方便后续操作。同时，可以使用JwtTokenProvider类生成和验证token。</span><br><span class="line"></span><br><span class="line">当Jwt token过期时，可以使用<span class="built_in">ref</span>resh token机制来处理。具体实现中，可以在生成token时，同时生成一个<span class="built_in">ref</span>resh token，并将其保存到数据库中。当token过期时，客户端可以使用<span class="built_in">ref</span>resh token来获取一个新的token。具体流程如下：</span><br><span class="line"></span><br><span class="line">客户端发送一个请求，包含过期的token和<span class="built_in">ref</span>resh token。</span><br><span class="line"></span><br><span class="line">后端验证<span class="built_in">ref</span>resh token的合法性，并生成一个新的token。</span><br><span class="line"></span><br><span class="line">后端将新的token和<span class="built_in">ref</span>resh token作为响应返回给客户端，并将新的token保存到SpringSecurity的上下文中。</span><br><span class="line"></span><br><span class="line">客户端在以后的请求中，使用新的token来进行操作。</span><br><span class="line"></span><br><span class="line">需要注意的是，<span class="built_in">ref</span>resh token也有过期时间，需要定期更新。此外，<span class="built_in">ref</span>resh token需要进行加密处理，以防止泄露。</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Redis</span>是一种基于内存的数据存储系统，支持多种数据类型。以下是<span class="variable">Redis</span>的基本数据类型：</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>：字符串类型，可以存储任意类型的数据，包括数字、文本、二进制数据等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hash</span>：哈希类型，可以存储键值对形式的数据，类似于<span class="variable">Java</span>中的<span class="built_in">Map</span>。</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>：列表类型，可以存储一组有序的数据，支持在列表头部和尾部进行插入和删除操作。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>：集合类型，可以存储一组无序的、不重复的数据，支持交集、并集、差集等操作。</span><br><span class="line"></span><br><span class="line"><span class="variable">Sorted</span> <span class="built_in">Set</span>：有序集合类型，可以存储一组有序的、不重复的数据，每个数据都有一个分值，支持根据分值进行排序。</span><br><span class="line"></span><br><span class="line">在我的项目中，我们主要使用了<span class="variable">Redis</span>的<span class="built_in">String</span>、<span class="built_in">Hash</span>、<span class="built_in">List</span>和<span class="built_in">Set</span>四种类型。具体使用场景如下：</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>：用于缓存一些简单的数据，例如用户登录信息、验证码等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hash</span>：用于缓存一些复杂的数据，例如用户信息、商品信息等，可以使用哈希表的形式存储多个字段。</span><br><span class="line"></span><br><span class="line"><span class="built_in">List</span>：用于实现队列和栈等数据结构，例如消息队列、操作日志等。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>：用于实现一些复杂的业务逻辑，例如排行榜、热门商品等。</span><br><span class="line"></span><br><span class="line">我们选择使用这些数据类型，主要是因为它们可以很好地满足我们的业务需求，同时<span class="variable">Redis</span>也提供了丰富的操作接口，方便我们对数据进行操作和管理。</span><br><span class="line"></span><br><span class="line">需要注意的是，在使用<span class="variable">Redis</span>时，需要注意数据类型的选择和数据存储的大小，避免出现数据丢失、性能问题等情况。同时，需要对<span class="variable">Redis</span>进行定期备份和监控，保证系统的可靠性和稳定性。</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MySQL索引失效主要有以下几种情况：</span><br><span class="line"></span><br><span class="line">数据量太小：如果表中的数据量太小，那么MySQL可能会直接进行全表扫描，而不是使用索引进行优化。</span><br><span class="line"></span><br><span class="line">索引列类型不匹配：如果查询条件与索引列数据类型不匹配，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上使用了函数或表达式：如果查询条件中使用了函数或表达式，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上使用了<span class="keyword">LIKE</span>操作符：如果查询条件中使用了<span class="keyword">LIKE</span>操作符，那么MySQL可能会只使用索引的前缀部分进行查询，而不是使用整个索引。</span><br><span class="line"></span><br><span class="line">索引列上使用了<span class="keyword">IS</span> <span class="keyword">NULL</span>或<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>操作符：如果查询条件中使用了<span class="keyword">IS</span> <span class="keyword">NULL</span>或<span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>操作符，那么MySQL可能会放弃使用索引进行查询。</span><br><span class="line"></span><br><span class="line">索引列上存在大量重复数据：如果索引列上存在大量重复数据，那么MySQL可能会放弃使用索引进行优化。</span><br><span class="line"></span><br><span class="line">在B+树中，索引失效的主要原因是因为查询的数据不在叶子节点上，导致需要进行多次磁盘读取才能找到目标数据。例如，如果查询的数据在B+树的叶子节点之外，那么MySQL可能会放弃使用索引进行查询，而进行全表扫描。</span><br><span class="line"></span><br><span class="line">此外，如果B+树的分裂和合并不平衡，也可能导致索引失效。如果分裂过于频繁，那么B+树的高度可能会增加，导致查询时需要进行更多的磁盘读取。如果合并过于频繁，那么B+树的节点数量可能会减少，导致索引的覆盖率降低，查询时需要进行更多的磁盘读取。</span><br><span class="line"></span><br><span class="line">因此，为了避免MySQL索引失效，需要合理地设计表结构、索引和查询语句，同时需要对MySQL进行优化和调优，保证系统的性能和稳定性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> IO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="/2023/04/14/28.JSON/"/>
      <url>/2023/04/14/28.JSON/</url>
      
        <content type="html"><![CDATA[<p>多线程</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单线程是指在一个程序中只有一个线程在运行，所有的任务都在这个线程中顺序执行。单线程的特点是简单、易于控制和调试，但是也存在一些问题，比如执行复杂任务时会阻塞程序的运行，影响程序的响应速度和并发处理能力。此外，若程序中的某个线程发生异常，整个程序可能会崩溃，影响用户的体验。单线程的应用场景比较有限，适合于简单的任务处理，如命令行界面的程序、小型工具类程序等。</span><br><span class="line"></span><br><span class="line">多线程是指在一个程序中同时运行多个线程，每个线程都可以独立运行，互不影响。多线程可以让程序更加高效地利用计算机的资源，提高程序的响应速度和并发处理能力。多线程的实现方式有很多种，如基于线程库的多线程，基于进程的多线程，以及基于操作系统的多线程等。多线程的应用场景包括服务器端的并发处理、图形界面程序的响应和数据处理等。</span><br><span class="line"></span><br><span class="line">线程是程序执行的基本单位，是操作系统中能够被操作和调度的最小单位。</span><br><span class="line">一个线程是由线程ID、程序计数器、寄存器集合和堆栈组成的。</span><br><span class="line">线程可以看作是进程中的一个独立执行单元，一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件句柄等。线程之间的切换是由操作系统内核进行调度，而不是由程序员直接控制。线程可以同时执行不同的任务，从而提高程序的并发处理能力和响应速度。线程的应用场景非常广泛，如服务器端的并发处理、图形界面程序的响应和数据处理等。</span><br></pre></td></tr></table></figure><p>锁</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Java中的锁是一种机制，用于协调多个线程对共享资源的访问。在Java中，锁有两种类型：内置锁和显式锁。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">内置锁是通过使用<span class="keyword">synchronized关键字来实现的。synchronized关键字可以放在方法声明中或代码块中，以确保在方法或代码块执行期间，只有一个线程可以访问被锁定的对象。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">显式锁是通过使用<span class="keyword">java.util.concurrent包中的Lock接口实现的。Lock接口提供了更灵活的锁定机制，包括可重入锁，公平锁和读写锁等。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">在<span class="keyword">Java中，锁的主要作用是避免多个线程同时访问共享资源，从而避免数据竞争和死锁等并发问题。使用锁可以确保线程安全，并且可以提高程序的性能和可靠性。</span></span><br></pre></td></tr></table></figure><p>死锁</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">死锁是指两个或多个线程在执行过程中，由于互相持有对方需要的资源而相互等待，导致程序无法继续执行下去的一种现象。简单来说，就是两个或多个线程都在等待对方释放资源，从而导致程序无法继续执行下去。</span><br><span class="line"></span><br><span class="line">死锁的产生通常有以下几个原因：</span><br><span class="line"></span><br><span class="line">竞争资源：多个线程同时竞争同一个资源，并且每个线程都持有自己的资源，但需要对方的资源才能继续执行。</span><br><span class="line"></span><br><span class="line">程序设计错误：程序中存在设计错误，使得多个线程在执行过程中出现了相互等待的情况。</span><br><span class="line"></span><br><span class="line">系统资源不足：系统资源不足，导致多个线程无法同时获得所需的资源。</span><br><span class="line"></span><br><span class="line">死锁产生后，程序将无法正常执行，只能通过强制结束程序或重启系统来解决。为避免死锁的产生，在编写程序时需要合理设计线程间的资源竞争关系，避免出现相互等待的情况，并且需要合理管理系统资源，保证资源的充足性。此外，还可以使用工具来检测和解决死锁问题，例如<span class="keyword">Java中的jstack和jconsole等工具。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">要解决死锁问题，首先需要了解死锁产生的原因。通常，死锁是由于多个线程相互等待彼此持有的锁而产生的。因此，解决死锁问题的方法主要有以下几种：</span><br><span class="line"></span><br><span class="line">避免死锁：在编写程序时，需要避免多个线程之间相互等待所需的资源。可以通过控制资源的分配顺序、避免嵌套锁等方式来避免死锁的产生。</span><br><span class="line"></span><br><span class="line">检测死锁：在程序运行过程中，可以通过工具检测死锁问题。例如，在<span class="keyword">Java中，jstack和jconsole等工具可以帮助我们检测死锁问题。</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">解除死锁：一旦发现死锁问题，需要通过一些手段来解除死锁。例如，可以通过中断某一个线程来打破死锁，或者通过调整锁的持有顺序来解除死锁。</span><br><span class="line"></span><br><span class="line">防止死锁：在多线程编程中，可以通过使用一些技术手段来防止死锁的产生。例如，使用超时机制、避免嵌套锁、使用非阻塞算法等方式来防止死锁的产生。</span><br><span class="line"></span><br><span class="line">总之，要解决死锁问题，需要从多个方面入手，包括避免死锁、检测死锁、解除死锁和防止死锁等方面。同时，也需要合理设计程序的资源竞争关系，保证程序的正确性和可靠性。</span><br></pre></td></tr></table></figure><p>代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Java中的代码块是一段被大括号包围的代码片段，也称为代码段。Java中常见的代码块有以下几种：</span><br><span class="line"></span><br><span class="line">实例代码块：在类中使用大括号包围的代码块，用于初始化实例变量。每次创建对象时，实例代码块都会被执行一次。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">静态代码块：在类中使用<span class="keyword">static</span>关键字和大括号包围的代码块，用于初始化静态变量。在类被加载时就会被执行，且只会执行一次。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        num = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">同步代码块：使用<span class="keyword">synchronized</span>关键字和大括号包围的代码块，用于控制多个线程对共享资源的访问。同步代码块只能被一个线程执行，其他线程需要等待。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">匿名代码块：在方法调用或对象创建过程中使用大括号包围的代码块，用于在不创建新类的情况下实现一些操作。匿名代码块在方法或对象初始化时被执行，且只会执行一次。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 匿名代码块</span></span><br><span class="line">                System.out.println(<span class="string">&quot;匿名代码块&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Threadlocal</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal是Java中的一个线程本地变量，它提供了一种在多线程环境下，每个线程都有自己独立的变量副本的方式。ThreadLocal通常用于实现线程安全的单例模式，或者在多线程环境下存储一些线程私有的数据。</span><br><span class="line"></span><br><span class="line">ThreadLocal的主要作用是在每个线程中创建一个独立的变量副本，这个变量可以在当前线程中被访问和修改，而不会影响其他线程中的变量。因此，ThreadLocal可以很好地解决多线程并发访问共享变量的问题。</span><br><span class="line"></span><br><span class="line">使用ThreadLocal的步骤通常包括以下几个：</span><br><span class="line"></span><br><span class="line">创建ThreadLocal对象。</span><br><span class="line"></span><br><span class="line">通过ThreadLocal对象的<span class="built_in">get</span>()方法获取当前线程的变量副本，如果当前线程没有变量副本，则会创建一个新的副本。</span><br><span class="line"></span><br><span class="line">通过ThreadLocal对象的<span class="built_in">set</span>()方法设置当前线程的变量副本。</span><br><span class="line"></span><br><span class="line">通过ThreadLocal对象的<span class="built_in">remove</span>()方法移除当前线程的变量副本。</span><br><span class="line"></span><br><span class="line">需要注意的是，ThreadLocal虽然可以解决多线程并发访问共享变量的问题，但也容易引起内存泄漏的问题。因为每个线程都有自己独立的变量副本，如果这些变量没有被正确地释放，就会一直存在于内存中，导致内存占用过高。因此，在使用ThreadLocal时，需要特别注意变量的生命周期，及时释放不再使用的变量。</span><br></pre></td></tr></table></figure><p>事务</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MySQL的事务（<span class="keyword">Transaction</span>）是指一组数据库操作，这些数据库操作要么全部执行成功，要么全部执行失败，不允许部分成功部分失败。事务可以保证数据库的完整性和一致性。</span><br><span class="line"></span><br><span class="line">MySQL的事务通常由以下四个特性所组成，也称为ACID特性：</span><br><span class="line"></span><br><span class="line">原子性（Atomicity）：事务中的所有操作都是原子的，要么全部执行成功，要么全部执行失败。如果事务在执行过程中出现错误，那么所有已经执行的操作都将被回滚，数据库状态也将被恢复到事务执行前的状态。</span><br><span class="line"></span><br><span class="line">一致性（Consistency）：事务执行前后，数据库的状态应该保持一致。在事务执行的过程中，如果数据发生了变化，那么这些变化应该是合法的，并且符合预期的结果。</span><br><span class="line"></span><br><span class="line">隔离性（<span class="keyword">Isolation</span>）：事务之间应该是相互隔离的，一个事务的执行不应该受到其他事务的影响。多个事务并发执行时，应该保证每个事务都能够访问到自己需要的数据，并且不会受到其他事务的干扰。</span><br><span class="line"></span><br><span class="line">持久性（Durability）：事务执行成功后，对数据库的影响应该是持久性的。即使系统发生故障或崩溃，数据库也应该能够恢复到事务执行成功后的状态。</span><br><span class="line"></span><br><span class="line">在MySQL中，可以使用<span class="keyword">BEGIN</span>、<span class="keyword">COMMIT</span>和<span class="keyword">ROLLBACK</span>等语句来控制事务的执行。<span class="keyword">BEGIN</span>语句用于开启一个事务，<span class="keyword">COMMIT</span>语句用于提交事务，<span class="keyword">ROLLBACK</span>语句用于回滚事务。可以使用<span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>语句来关闭自动提交模式，这样所有的DML语句都必须手动提交或回滚事务。</span><br></pre></td></tr></table></figure><p>声明式事务与编程式事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">声明式事务和编程式事务是两种处理事务的方式。</span><br><span class="line"></span><br><span class="line">声明式事务是通过在配置文件或注解中声明事务属性，由框架自动管理事务的提交和回滚，开发者无需手动管理事务。声明式事务的优点是可以使代码更加简洁，减少了事务管理的代码量，同时也能够使代码更加清晰易懂。常见的框架中，Spring框架支持声明式事务的管理。</span><br><span class="line"></span><br><span class="line">编程式事务是通过编写代码手动管理事务的提交和回滚。开发者需要在代码中明确的调用事务的开始、提交和回滚等操作。编程式事务的优点是可以更加灵活的控制事务的执行，可以根据具体的业务需求进行定制，但是缺点是需要手动编写大量的事务管理代码，代码可读性较差。常见的框架中，Hibernate框架支持编程式事务的管理。</span><br><span class="line"></span><br><span class="line">需要注意的是，声明式事务和编程式事务并不是互相排斥的关系，两者可以结合使用。例如，在Spring框架中，可以使用声明式事务来管理大量的简单事务，同时在某些特殊的情况下，也可以使用编程式事务来进行定制。</span><br><span class="line"></span><br><span class="line">BEGIN语句用于开启一个事务，COMMIT语句用于提交事务，ROLLBACK语句用于回滚事务</span><br><span class="line"></span><br><span class="line">声明式事务</span><br><span class="line"><span class="meta">@Transactional</span>开启事务</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>开启事务管理</span><br><span class="line">编程式事务</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String fromUser, String toUser, Double amount)</span> &#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                userDao.withdraw(fromUser, amount);</span><br><span class="line">                userDao.deposit(toUser, amount);</span><br><span class="line">                <span class="comment">// 如果遇到异常，手动回滚事务</span></span><br><span class="line">                <span class="keyword">if</span> (amount &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>索引</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">索引（<span class="keyword">Index</span>）是数据库中用于提高查询效率的一种数据结构，它可以帮助数据库快速定位到包含特定值的数据行，从而加速查询操作。数据库中的索引类似于字典中的目录，可以让我们更快地找到需要的内容。</span><br><span class="line"></span><br><span class="line">索引通常是在表的某个列上创建的，它们可以是唯一的或非唯一的。唯一索引可以保证该列中的所有值都是唯一的，而非唯一索引则不要求该列中的值是唯一的。索引可以包含多个列，这些列可以是表中的任意列。</span><br><span class="line"></span><br><span class="line">在使用索引时，虽然可以加快查询速度，但是也会增加写入操作的时间和空间开销。因此，在设计索引时需要权衡查询和写入操作的比例，避免过度索引导致性能下降。</span><br></pre></td></tr></table></figure><p>存储引擎</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">存储引擎（<span class="keyword">Storage</span> Engine）是数据库管理系统中用于处理数据存储和检索的组件，它决定了数据库如何存储数据、如何索引数据以及如何读取和更新数据。不同的存储引擎有不同的特性和优缺点，开发者需要根据具体的应用场景选择合适的存储引擎。</span><br><span class="line"></span><br><span class="line">常见的存储引擎包括：</span><br><span class="line"></span><br><span class="line">InnoDB：InnoDB是MySQL中默认的存储引擎，它支持事务、外键和行级锁等特性，具有较高的并发性和可靠性，适合于高并发的应用场景。</span><br><span class="line"></span><br><span class="line">MyISAM：MyISAM是MySQL中另一种常用的存储引擎，它不支持事务和外键等特性，但具有较高的查询性能和较低的存储空间开销，适合于读频繁、写较少的应用场景。</span><br></pre></td></tr></table></figure><p>数据库</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数据库：存储数据的容器，通常由表、索引、视图等组成。</span><br><span class="line"></span><br><span class="line">表：数据库中的数据存储在表中，表由多个行和列组成。</span><br><span class="line"></span><br><span class="line">列：表中的一列，用于存储同一类型的数据。</span><br><span class="line"></span><br><span class="line">行：表中的一行，包含了多列数据。</span><br><span class="line"></span><br><span class="line">主键：用于唯一标识表中的每个行的列或列组合，确保数据的唯一性和完整性。</span><br><span class="line"></span><br><span class="line">外键：表中的一列或一组列，用于建立与其他表的关联关系，保证数据的一致性。</span><br><span class="line"></span><br><span class="line">索引：用于提高查询效率的一种数据结构，可以加速查询操作。</span><br><span class="line"></span><br><span class="line">事务：一组数据库操作的有序集合，要么全部执行成功，要么全部执行失败。</span><br><span class="line"></span><br><span class="line">视图：虚拟的表，由一个或多个表的行组成，可以看作是一种预定义的查询。</span><br><span class="line"></span><br><span class="line">存储引擎：用于处理数据存储和检索的组件，决定了数据库如何存储数据、如何索引数据以及如何读取和更新数据。</span><br><span class="line"></span><br><span class="line">备份和恢复：用于保护数据库数据的重要手段，可以通过备份和恢复操作来避免数据丢失和损坏。</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>：结构化查询语言，用于对数据库进行查询、修改和管理的语言。</span><br><span class="line"></span><br><span class="line">NoSQL：非关系型数据库，与传统关系型数据库不同，采用不同的数据存储和查询方式，适用于大数据和高并发的场景。</span><br><span class="line"></span><br><span class="line">ACID：代表原子性（Atomicity）、一致性（Consistency）、隔离性（<span class="keyword">Isolation</span>）和持久性（Durability），是事务的四个基本特性。</span><br></pre></td></tr></table></figure><p>视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">数据库的视图是一种虚拟表，它是由一个或多个基本表的行和列组成的。视图并不存储数据，而是通过查询语句从基本表中获取数据，并根据特定的条件过滤、排序、组合和聚合数据。视图可以隐藏基本表的复杂性，简化用户的数据访问和操作，并提供更高的数据安全性和保密性。</span><br><span class="line"></span><br><span class="line">视图可以看作是一个逻辑表，它包含了一个或多个基本表的某些列或行的子集。通过视图，用户可以方便地查询和操作特定的数据，而不需要了解基本表的细节和复杂性。视图还可以通过定义计算字段、聚合函数、联接和子查询等高级操作，提供更灵活和强大的数据处理能力。</span><br><span class="line"></span><br><span class="line">视图的主要优点包括：</span><br><span class="line"></span><br><span class="line">简化数据访问和操作：视图可以隐藏基本表的复杂性，提供更简单、直观和易用的数据接口。</span><br><span class="line"></span><br><span class="line">提高数据安全性和保密性：视图可以限制用户访问数据的范围和权限，保护敏感数据的安全性和保密性。</span><br><span class="line"></span><br><span class="line">提高性能和可维护性：视图可以优化查询性能，减少数据冗余和重复，提高数据一致性和可维护性。</span><br><span class="line"></span><br><span class="line">支持高级操作和应用：视图可以定义计算字段、聚合函数、联接和子查询等高级操作，提供更灵活和强大的数据处理能力，支持各种应用场景和需求。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用视图需要以下步骤：</span><br><span class="line"></span><br><span class="line">创建视图：使用 <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 语句创建视图，指定视图的名称、列名和查询语句。</span><br><span class="line"></span><br><span class="line">查询视图：使用 <span class="keyword">SELECT</span> 语句查询视图，就像查询表一样。</span><br><span class="line">可以使用 <span class="keyword">WHERE</span> 子句、<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句、<span class="keyword">GROUP</span> <span class="keyword">BY</span>子句等对视图进行过滤、排序、分组等操作。</span><br><span class="line"></span><br><span class="line">修改视图：使用 <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 语句修改视图的定义。可以添加、删除、重命名列，修改查询语句等。</span><br><span class="line"></span><br><span class="line">删除视图：使用 <span class="keyword">DROP</span> <span class="keyword">VIEW</span> 语句删除视图，释放与视图相关的资源和内存。</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例，演示如何创建和使用视图：</span><br><span class="line"></span><br><span class="line">创建视图：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> v_customer <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_id, customer_name, customer_email</span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">WHERE</span> customer_status <span class="operator">=</span> <span class="string">&#x27;Active&#x27;</span>;</span><br><span class="line"></span><br><span class="line">查询视图：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> v_customer;</span><br><span class="line"></span><br><span class="line">修改视图：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> v_customer</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> customer_phone <span class="type">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">删除视图：</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> v_customer;</span><br><span class="line">需要注意的是，视图并不是真实的表，它只是一个虚拟的表，实际的数据仍然存储在基本表中。视图的查询语句必须符合基本表的结构和数据类型，否则会报错。视图也不支持所有的操作，例如插入、更新和删除操作，只能用于查询和展示数据。</span><br></pre></td></tr></table></figure><p>注解</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot中的核心注解包括：</span><br><span class="line">@SpringBootApplication 是一个组合注解，它整合了多个注解，包括：</span><br><span class="line">@Configuration：标注在类上，表示该类是一个配置类，用于配置和组合Spring Bean。</span><br><span class="line">@EnableAutoConfiguration：标注在类上，表示启用Spring Boot的自动配置特性，自动配置Spring上下文和其他配置信息。</span><br><span class="line">@ComponentScan：标注在类上，用于自动扫描并加载Spring Bean。</span><br><span class="line">这三个注解的作用分别是：</span><br><span class="line">@Configuration：声明该类是一个配置类，用于配置和组合Spring Bean。</span><br><span class="line">@EnableAutoConfiguration：开启Spring Boot的自动配置功能，根据依赖和配置自动配置Spring上下文和其他配置信息。</span><br><span class="line">@ComponentScan：自动扫描并加载Spring Bean，自动装配Bean。</span><br><span class="line">因此，@SpringBootApplication注解的作用是整合@Configuration、@EnableAutoConfiguration和@ComponentScan注解，用于简化Spring Boot应用的配置和启动过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SpringBootApplication：标注在启动类上，表示该类为Spring Boot的入口类，自动配置Spring上下文和其他配置信息。</span><br><span class="line">@RestController：标注在Controller类上，表示该类处理HTTP请求并返回<span class="built_in">JSON</span>格式的数据。</span><br><span class="line">@RequestMapping：标注在Controller类或方法上，用于映射请求的URL地址和HTTP请求方法。</span><br><span class="line">@Autowired：标注在字段、setter方法或构造方法上，用于自动注入依赖对象。</span><br><span class="line">@Service：标注在服务类上，表示该类是服务层组件，通常用于处理业务逻辑。</span><br><span class="line">@Repository：标注在数据访问层类上，表示该类是数据访问层组件，通常用于访问数据库或其他数据源。</span><br><span class="line">@Component：标注在通用组件上，表示该类是一个通用组件。</span><br><span class="line">@Configuration：标注在配置类上，表示该类是一个配置类，用于配置和组合Spring Bean。</span><br><span class="line">@Bean：标注在方法上，用于声明一个Spring Bean。</span><br><span class="line">@Value：标注在字段、setter方法或构造方法上，用于注入配置文件中的值。</span><br><span class="line">@Profile：标注在类或方法上，用于指定Spring应该使用哪个配置文件或Bean。</span><br><span class="line">@EnableAutoConfiguration：标注在启动类上，表示启用Spring Boot的自动配置</span><br></pre></td></tr></table></figure><p>反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Java 反射是指在运行时动态地获取类的信息和调用类的方法和属性。Java 反射 API 提供了许多类和接口，可以在运行时获取类的信息，例如类的名称、父类、接口、字段、方法、构造方法等，还可以动态地创建对象、调用方法、设置属性等。Java 反射可以使程序更加灵活和动态，但也会带来一些性能和安全方面的问题，需要谨慎使用。</span><br><span class="line">    </span><br><span class="line">反射和 <span class="keyword">new</span> 创建对象的区别主要在以下几个方面：</span><br><span class="line"></span><br><span class="line">编译时 vs 运行时：使用 <span class="keyword">new</span> 创建对象是在编译时确定的，而使用反射创建对象是在运行时动态确定的。</span><br><span class="line"></span><br><span class="line">类型检查 vs 动态类型：使用 <span class="keyword">new</span> 创建对象时，编译器会进行类型检查，确保类型正确；而使用反射创建对象时，类型检查是在运行时进行的，可以动态地创建不同类型的对象。</span><br><span class="line"></span><br><span class="line">性能 vs 灵活性：使用 <span class="keyword">new</span> 创建对象的性能比使用反射创建对象要高，因为反射需要进行额外的类型检查和方法调用；而使用反射创建对象的灵活性比使用 <span class="keyword">new</span> 创建对象要高，因为可以动态地加载类和调用方法。</span><br><span class="line"></span><br><span class="line">安全性 vs 风险性：使用 <span class="keyword">new</span> 创建对象比使用反射创建对象更加安全，因为 <span class="keyword">new</span> 创建对象时可以确保类型正确，而使用反射创建对象时需要谨慎处理类型和方法的访问权限，否则可能会导致安全问题。</span><br><span class="line"></span><br><span class="line">总的来说，使用 <span class="keyword">new</span> 创建对象更加简单、直接、安全和高效，适用于大多数情况下；而使用反射创建对象则更加灵活、动态和风险。需要根据具体的需求和场景选择合适的方式。</span><br></pre></td></tr></table></figure><p>UNION</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UNION</span> 是 <span class="keyword">SQL</span> 中的一个关键字，用于合并两个或多个 <span class="keyword">SELECT</span> 语句的结果集。<span class="keyword">UNION</span> 的语法格式如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ... <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> condition1</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ... <span class="keyword">FROM</span> table2 <span class="keyword">WHERE</span> condition2</span><br><span class="line">[<span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ... <span class="keyword">FROM</span> table3 <span class="keyword">WHERE</span> condition3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span> 的作用是将多个 <span class="keyword">SELECT</span> 语句的结果集合并成一个结果集，并去除重复的行。如果使用 <span class="keyword">UNION</span> <span class="keyword">ALL</span>，则会保留重复的行。</span><br><span class="line"></span><br><span class="line">以下是一个简单的示例，演示如何使用 <span class="keyword">UNION</span> 语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> customer_name, customer_email <span class="keyword">FROM</span> customers <span class="keyword">WHERE</span> customer_status <span class="operator">=</span> <span class="string">&#x27;Active&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> customer_name, customer_email <span class="keyword">FROM</span> past_customers <span class="keyword">WHERE</span> customer_status <span class="operator">=</span> <span class="string">&#x27;Inactive&#x27;</span>;</span><br><span class="line">在上面的示例中，使用 <span class="keyword">UNION</span> 语句将两个 <span class="keyword">SELECT</span> 语句的结果集合并成一个结果集，并去除重复的行。需要注意的是，<span class="keyword">UNION</span> 的前后两个 <span class="keyword">SELECT</span> 语句的列数和数据类型必须一致，否则会报错。同时，<span class="keyword">UNION</span> 的性能比较低，因为需要进行多次查询和排序操作，如果数据量比较大，可能会影响查询效率。</span><br></pre></td></tr></table></figure><p>IO</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Java 的 IO（Input/Output）主要包括输入和输出两部分，用于处理数据的读写操作。Java 提供了多种 <span class="built_in">IO</span> 类型和 API，可以满足不同的需求和场景。</span><br><span class="line"></span><br><span class="line">Java 的 <span class="built_in">IO</span> 主要包括以下几种类型：</span><br><span class="line"></span><br><span class="line">字节流和字符流：Java 的 <span class="built_in">IO</span> 分为字节流和字符流两种类型。字节流以字节为单位读写数据，一般用于处理二进制数据；字符流以字符为单位读写数据，一般用于处理文本数据。</span><br><span class="line"></span><br><span class="line">输入流和输出流：Java 的 <span class="built_in">IO</span> 又分为输入流和输出流两种类型。输入流用于读取数据，输出流用于写入数据。</span><br><span class="line"></span><br><span class="line">节点流和处理流：Java 的 <span class="built_in">IO</span> 还分为节点流和处理流两种类型。节点流直接与数据源相连，处理流则是对节点流的包装，提供了额外的功能和处理能力。</span><br><span class="line"></span><br><span class="line">Java 的 <span class="built_in">IO</span> API 主要包括以下几个类：</span><br><span class="line"></span><br><span class="line">InputStream 和 OutputStream：字节输入流和字节输出流的基类。</span><br><span class="line"></span><br><span class="line">Reader 和 Writer：字符输入流和字符输出流的基类。</span><br><span class="line"></span><br><span class="line">FileInputStream 和 FileOutputStream：读写文件的字节流类。</span><br><span class="line"></span><br><span class="line">FileReader 和 FileWriter：读写文件的字符流类。</span><br><span class="line"></span><br><span class="line">ByteArrayInputStream 和 ByteArrayOutputStream：在内存中读写字节数据的流类。</span><br><span class="line"></span><br><span class="line">CharArrayReader 和 CharArrayWriter：在内存中读写字符数据的流类。</span><br><span class="line"></span><br><span class="line">BufferedReader 和 BufferedWriter：提供缓存功能的字符流类。</span><br><span class="line"></span><br><span class="line">DataInputStream 和 DataOutputStream：读写基本数据类型和字符串的字节流类。</span><br><span class="line"></span><br><span class="line">ObjectInputStream 和 ObjectOutputStream：读写对象的字节流类。</span><br><span class="line"></span><br><span class="line">Java 的 <span class="built_in">IO</span> API 还提供了大量的工具类和接口，例如 File、Path、Charset、Scanner、PrintWriter 等，可以更方便地处理文件、编码、格式化、扫描等操作。</span><br><span class="line"></span><br><span class="line">需要注意的是，Java 的 <span class="built_in">IO</span> API 在处理大量数据和高并发的情况下可能会出现性能问题，需要根据具体场景选择合适的 <span class="built_in">IO</span> 方式和 API。另外，Java <span class="number">7</span> 引入了 NIO（New IO） API，提供了更高效的 <span class="built_in">IO</span> 处理方式，可以进一步提高系统的性能和可靠性。</span><br></pre></td></tr></table></figure><p>Redis为什么是单线程的</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Redis 之所以是单线程的，主要是为了避免多线程情况下的竞争和锁等问题，从而提高并发性能和可靠性。Redis 使用单线程的方式，将任务队列和网络 <span class="built_in">IO</span> 分离，通过异步非阻塞的方式来处理请求和响应，可以充分利用 CPU 和内存资源，提高系统的吞吐量和响应速度。</span><br><span class="line"></span><br><span class="line">具体来说，Redis 的单线程模型主要体现在以下几个方面：</span><br><span class="line"></span><br><span class="line">任务队列：Redis 使用任务队列来保存客户端的请求，请求按照先进先出的顺序进行处理。任务队列的设计可以避免多线程情况下的锁等竞争问题，提高系统的并发性能和可靠性。</span><br><span class="line"></span><br><span class="line">网络 IO：Redis 使用多路复用的方式来处理网络 IO，通过异步非阻塞的方式来处理客户端的请求和响应。这种方式可以在单线程的情况下同时处理多个客户端的请求和响应，提高系统的吞吐量和响应速度。</span><br><span class="line"></span><br><span class="line">数据结构：Redis 使用单线程处理数据结构的读写操作，避免了多线程情况下的同步和锁等问题。同时，Redis 的数据结构设计非常简单和高效，可以充分利用 CPU 和内存资源，提高系统的性能和可靠性。</span><br><span class="line"></span><br><span class="line">需要注意的是，Redis 的单线程模型并不是绝对的单线程，Redis 在处理网络 <span class="built_in">IO</span> 的同时，也会使用多个子线程来处理后台任务，例如持久化、复制、集群等。但是，这些子线程对于客户端请求的处理没有直接的影响，Redis 的主线程仍然是单线程处理客户端请求和响应的。</span><br></pre></td></tr></table></figure><p>事务传播行为、隔离级别</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">事务传播行为指的是事务提交后，对其他事务的可见性。</span><br><span class="line">隔离级别指的是多个事务之间互相隔离的程度。</span><br><span class="line"></span><br><span class="line"><span class="section">常见的事务传播行为包括:</span></span><br><span class="line"><span class="section">PROPAGATION_REQUIRED:如果当前存在事务，则加入该事务，否则创建一个新事务。</span></span><br><span class="line"><span class="section">PROPAGATION_SUPPORTS:如果当前存在事务，则加入该事务，否则以非事务方式执行。</span></span><br><span class="line"><span class="section">PROPAGATION_MANDATORY:必须存在当前事务，否则抛出异常。</span></span><br><span class="line"><span class="section">PROPAGATION_REQUIRES_NEW:创建一个新事务，如果当前存在事务，则挂起该事务。</span></span><br><span class="line"><span class="section">PROPAGATION_NOT_SUPPORTED:以非事务方式执行，如果当前存在事务，则挂起该事务。</span></span><br><span class="line"><span class="section">PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。</span></span><br><span class="line"><span class="section">PROPAGATION_NESTED:如果当前存在事务，则在该事务的嵌套事务中执行，否则创建一个新事务。</span></span><br><span class="line"></span><br><span class="line"><span class="section">常见的隔离级别包括:</span></span><br><span class="line"><span class="section">READ_UNCOMMITTED:允许读取未提交的数据，存在脏读问题。</span></span><br><span class="line"><span class="section">READ_COMMITTED:只能读取已经提交的数据，不存在脏读问题，但存在不可重复读和幻读问题。</span></span><br><span class="line"><span class="section">REPEATABLE_READ:保证在同一个事务中多次读取同一数据时得到的结果是一致的，不存在不可重复读问题，但存在幻读问题。</span></span><br><span class="line"><span class="section">SERIALIZABLE:完全隔离事务，保证不存在脏读、不可重复读和幻读问题，但性能较差。</span></span><br></pre></td></tr></table></figure><p>聚簇索引和非聚簇索引</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在 MySQL 默认引擎 InnoDB 中，索引大致可分为两类：聚簇索引和非聚簇索引</span><br><span class="line">聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</span><br><span class="line">在聚簇索引的叶子节点直接存储用户信息的内存地址，我们使用内存地址可以直接找到相应的行数据。</span><br><span class="line">聚簇索引在 InnoDB 中是使用 <span class="selector-tag">B</span>+ 树实现的</span><br><span class="line"></span><br><span class="line">非聚簇索引在 InnoDB 引擎中，也叫二级索引</span><br><span class="line">在非聚簇索引的叶子节点上存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，我们把这个过程称之为回表查询。</span><br><span class="line"></span><br><span class="line">在 MySQL 的 InnoDB 引擎中，每个索引都会对应一颗 <span class="selector-tag">B</span>+ 树，而聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询</span><br><span class="line"></span><br><span class="line">聚簇索引叶子节点存储的是行数据；而非聚簇索引叶子节点存储的是聚簇索引（通常是主键 ID）。</span><br><span class="line">聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引。</span><br><span class="line">聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</span><br></pre></td></tr></table></figure><p>BLOG文章复习</p><p>简历知识点复习</p><p>简历编写</p><p>项目描述</p><p>简历项目修改</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">常见的索引类型包括：</span><br><span class="line"></span><br><span class="line"><span class="variable">B</span><span class="operator">-</span><span class="variable">tree</span>索引：<span class="variable">B</span><span class="operator">-</span><span class="variable">tree</span>是一种多路搜索树，常用于实现数据库索引。<span class="variable">B</span><span class="operator">-</span><span class="variable">tree</span>索引支持快速查找，可以在<span class="built_in">O</span><span class="punctuation">(</span><span class="variable">log</span> <span class="variable">n</span><span class="punctuation">)</span>的时间复杂度内定位到需要的数据。</span><br><span class="line"></span><br><span class="line"><span class="built_in">Hash</span>索引：<span class="built_in">Hash</span>索引使用哈希表来实现，可以在<span class="built_in">O</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">)</span>的时间复杂度内查找数据。但是，<span class="built_in">Hash</span>索引只支持精确匹配，不支持范围查找。</span><br><span class="line"></span><br><span class="line">全文索引：全文索引支持对文本内容进行搜索，可以在文本中查找关键字，支持模糊匹配等操作。</span><br><span class="line"></span><br><span class="line">空间索引：空间索引用于处理地理位置等带有空</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2023/04/14/27.VUE/"/>
      <url>/2023/04/14/27.VUE/</url>
      
        <content type="html"><![CDATA[<p>REPEATABLE READ是MySQL中的一种事务隔离级别，它提供了最高的事务隔离级别。在REPEATABLE READ级别下，当事务开始时，会对所有读取的数据进行加锁，保证在整个事务过程中，读取的数据不会被其他事务修改。这样可以避免脏读、不可重复读和幻读等问题。</p><p>在REPEATABLE READ级别下，当事务读取数据时，会将数据从磁盘读取到内存中，并锁定该数据，直到事务提交或回滚。因此，在REPEATABLE READ级别下，会有一定的性能损失和锁竞争问题。</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI</title>
      <link href="/2023/04/02/26.UI/"/>
      <url>/2023/04/02/26.UI/</url>
      
        <content type="html"><![CDATA[<h5 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.Java基础"></a>1.Java基础</h5><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>的遍历</span><br><span class="line"></span><br><span class="line">keyset</span><br><span class="line"><span class="built_in">values</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">put</span></span><br><span class="line"><span class="built_in">remove</span></span><br></pre></td></tr></table></figure><h5 id="2-hashmap的特性"><a href="#2-hashmap的特性" class="headerlink" title="2.hashmap的特性"></a>2.hashmap的特性</h5><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>允许空键和空值（空键只能有一个）</span><br><span class="line"><span class="number">2.</span>元素无序</span><br><span class="line"><span class="number">3.</span><span class="built_in">key</span>用<span class="built_in">set</span>类型存放，<span class="built_in">key</span>对应的类需要重写hashcode和equals方法</span><br><span class="line"><span class="number">4.</span>底层实现是链表数组，Jdk8后加了红黑树</span><br><span class="line"><span class="number">5.</span>实现了<span class="built_in">map</span>的所有方法</span><br></pre></td></tr></table></figure><h5 id="3-jvm的虚拟内存模型"><a href="#3-jvm的虚拟内存模型" class="headerlink" title="3.jvm的虚拟内存模型"></a>3.jvm的虚拟内存模型</h5><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法区</span><br><span class="line"><span class="keyword">java堆</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">java栈</span></span><br><span class="line"><span class="keyword"></span>本地方法栈</span><br></pre></td></tr></table></figure><h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4.异常"></a>4.异常</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根异常类throwable</span><br><span class="line"><span class="built_in">Error</span>和<span class="built_in">Exception</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Exception</span>分为ioException和runtimeException</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:无论异常是否发生，都会执行</span><br></pre></td></tr></table></figure><h5 id="5-创建线程的几种方式"><a href="#5-创建线程的几种方式" class="headerlink" title="5.创建线程的几种方式"></a>5.创建线程的几种方式</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">继承thread类</span><br><span class="line"></span><br><span class="line">实现runnable接口</span><br></pre></td></tr></table></figure><h5 id="6-垃圾回收机制"><a href="#6-垃圾回收机制" class="headerlink" title="6.垃圾回收机制"></a>6.垃圾回收机制</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回收的是内存，<span class="built_in">GC</span>回收的是堆区和方法区的内存</span><br></pre></td></tr></table></figure><h5 id="7-hashcode和equal的区别"><a href="#7-hashcode和equal的区别" class="headerlink" title="7.hashcode和equal的区别"></a>7.hashcode和equal的区别</h5><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hashcode</span>()方法是本地方法，返回的是对象的地址值</span><br><span class="line"><span class="selector-tag">object</span>类中的<span class="built_in">equals</span>()方法比较的也是两个对象的地址值</span><br><span class="line"></span><br><span class="line">在String类中，<span class="built_in">equals</span>()返回的是两个对象内容的比较，当两个对象内容相等时，<span class="built_in">Hashcode</span>()方法根据String类的重写代码的分析，也可知道<span class="built_in">hashcode</span>()返回结果也会相等。</span><br></pre></td></tr></table></figure><h5 id="8-arraylist和linketlist的区别"><a href="#8-arraylist和linketlist的区别" class="headerlink" title="8.arraylist和linketlist的区别"></a>8.arraylist和linketlist的区别</h5><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>list基于动态数组，查询快</span><br><span class="line"></span><br><span class="line">linketlist基于链表，增删快</span><br></pre></td></tr></table></figure><h5 id="9-事务"><a href="#9-事务" class="headerlink" title="9.事务"></a>9.事务</h5><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230312152033440.png" alt="image-20230312152033440" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web</title>
      <link href="/2023/04/02/25.Web/"/>
      <url>/2023/04/02/25.Web/</url>
      
        <content type="html"><![CDATA[<h5 id="1-cookie和session"><a href="#1-cookie和session" class="headerlink" title="1.cookie和session"></a>1.cookie和session</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单个cookie不能超过<span class="number">4</span>k</span><br><span class="line">浏览器最多只能保存<span class="number">20</span>个cookie</span><br><span class="line"></span><br><span class="line"><span class="keyword">session</span>生成的sessionid保存在cookie中</span><br></pre></td></tr></table></figure><h5 id="2-转发和重定向"><a href="#2-转发和重定向" class="headerlink" title="2.转发和重定向"></a>2.转发和重定向</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">转发:转到一个新的地址，一次请求，共享数据，地址不改变，同一应用的某个地址</span></span><br><span class="line"></span><br><span class="line"><span class="section">重定向:重新发送请求，两次请求，不共享数据，地址改变，可以是任意地址</span></span><br></pre></td></tr></table></figure><h5 id="3-ajax的书写方式"><a href="#3-ajax的书写方式" class="headerlink" title="3.ajax的书写方式"></a>3.ajax的书写方式</h5><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.ajax()</span><br><span class="line">$.getJson()</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230312153747797.png" alt="image-20230312153747797" style="zoom:67%;" /><h5 id="4-拦截器和过滤器的区别"><a href="#4-拦截器和过滤器的区别" class="headerlink" title="4.拦截器和过滤器的区别"></a>4.拦截器和过滤器的区别</h5><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拦截器是<span class="keyword">spring</span>的组件，可以使用<span class="keyword">spring</span>的资源，过滤器不可以</span><br><span class="line"></span><br><span class="line">拦截器基于java反射机制，过滤器基于函数回调</span><br><span class="line"></span><br><span class="line">拦截器不依赖于servlet。过滤器依赖于servlet，<span class="keyword">filter</span>定义在web.xml中</span><br></pre></td></tr></table></figure><h5 id="5-一次完整的http请求"><a href="#5-一次完整的http请求" class="headerlink" title="5.一次完整的http请求"></a>5.一次完整的http请求</h5><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230312154232470.png" alt="image-20230312154232470" style="zoom:67%;" /><h5 id="6-jsp的四大作用域"><a href="#6-jsp的四大作用域" class="headerlink" title="6.jsp的四大作用域"></a>6.jsp的四大作用域</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">page:</span>当前页面</span><br><span class="line"><span class="symbol">requset:</span>当前请求有效</span><br><span class="line"><span class="symbol">session:</span>当前会话有效</span><br><span class="line"><span class="symbol">application:</span>所有应用程序有效</span><br></pre></td></tr></table></figure><h5 id="7-表单重复提交"><a href="#7-表单重复提交" class="headerlink" title="7.表单重复提交"></a>7.表单重复提交</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.数据库主键唯一</span><br><span class="line">2.提交成功后重定向</span><br><span class="line">3.提交后隐藏或不可用提交按钮</span><br></pre></td></tr></table></figure><h5 id="8-常见端口"><a href="#8-常见端口" class="headerlink" title="8.常见端口"></a>8.常见端口</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ftp</span>：<span class="number">21</span></span><br><span class="line"><span class="attribute">telnet</span>：<span class="number">23</span></span><br></pre></td></tr></table></figure><h5 id="9-常见状态码"><a href="#9-常见状态码" class="headerlink" title="9.常见状态码"></a>9.常见状态码</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">100：继续发送请求</span><br><span class="line">202：请求已被受理还未响应</span><br><span class="line">400：请求无效，请求参数有误</span><br><span class="line">404：无法访问资源</span><br><span class="line">500：后端错误</span><br></pre></td></tr></table></figure><h5 id="10-tcp和udp"><a href="#10-tcp和udp" class="headerlink" title="10.tcp和udp"></a>10.tcp和udp</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp：面向连接，通道内传输</span><br><span class="line">udp：无连接，传输数据为分组报文，适合大数据的传输</span><br></pre></td></tr></table></figure><h5 id="11-json的数据格式"><a href="#11-json的数据格式" class="headerlink" title="11.json的数据格式"></a>11.json的数据格式</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象：花括号</span><br><span class="line">数组：方括号</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2023/04/02/24.%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/04/02/24.%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h5 id="1-spring的事务机制"><a href="#1-spring的事务机制" class="headerlink" title="1.spring的事务机制"></a>1.spring的事务机制</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包括声明式事务和编程式事务</span><br><span class="line"></span><br><span class="line">声明式事务通过aop面向切面编程实现，目标方法执行前进行拦截，目标方法执行前加入或创建一个事务，在执行方法执行后，根据实际情况选择提交或回滚事务</span><br></pre></td></tr></table></figure><h5 id="2-aop的实现原理"><a href="#2-aop的实现原理" class="headerlink" title="2.aop的实现原理"></a>2.aop的实现原理</h5><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aop的动态代理主要由两种方法实现：</span><br><span class="line">jdk动态代理和cglib动态代理</span><br><span class="line"></span><br><span class="line">JDK动态代理：利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</span><br><span class="line">CGib动态代理：利用<span class="keyword">ASM</span>(开源的Java字节码编辑库，操作字节码)开源包，将代理对象类的<span class="keyword">class</span>文件加载进来，通过修改其字节码生成子类来处理。</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230312162034677.png" alt="image-20230312162034677" style="zoom:67%;" /><h5 id="3-Ioc和Di"><a href="#3-Ioc和Di" class="headerlink" title="3.Ioc和Di"></a>3.Ioc和Di</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioc是容器，<span class="keyword">di</span>是注入这个行为。</span><br></pre></td></tr></table></figure><h5 id="4-bean的作用域"><a href="#4-bean的作用域" class="headerlink" title="4.bean的作用域"></a>4.bean的作用域</h5><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230313165417365.png" alt="image-20230313165417365" style="zoom:67%;" /><h5 id="5-springmvc"><a href="#5-springmvc" class="headerlink" title="5.springmvc"></a>5.springmvc</h5><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springMVC的入口是一个servlet即前端控制器</span><br><span class="line">springMVC是基于方法开发，传递参数是通过方法形参，可以设计为单例或多例（建议单例）</span><br><span class="line">springMVC通过参数绑定将<span class="built_in">request</span>请求内容解析，并给方法形参赋值</span><br></pre></td></tr></table></figure><h5 id="6-springmvci前端控制器是什么？处理器映射器是什么？"><a href="#6-springmvci前端控制器是什么？处理器映射器是什么？" class="headerlink" title="6.springmvci前端控制器是什么？处理器映射器是什么？"></a>6.springmvci前端控制器是什么？处理器映射器是什么？</h5><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前端控制器是DispatcherServlet,处理器映射器是HandlerMapping。</span><br><span class="line">核心答案讲解：</span><br><span class="line"><span class="symbol">DispatcherServlet:</span>前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c,DispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。</span><br><span class="line"><span class="symbol">HandlerMapping:</span>处理器映射器。HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</span><br></pre></td></tr></table></figure><h5 id="7-springmvc如何进行参数绑定"><a href="#7-springmvc如何进行参数绑定" class="headerlink" title="7.springmvc如何进行参数绑定"></a>7.springmvc如何进行参数绑定</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理器适配器调用springmvc:提供的参数绑定组件将前端传入的key/value数据转成controller方法的形参。</span><br></pre></td></tr></table></figure><h5 id="8-springmvc获取表单数据的几种方式？"><a href="#8-springmvc获取表单数据的几种方式？" class="headerlink" title="8.springmvc获取表单数据的几种方式？"></a>8.springmvc获取表单数据的几种方式？</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Controller的方法，添加HttpServletRequst类型入参，通过<span class="module-access"><span class="module"><span class="identifier">HttpServletRequst</span>.</span></span>get<span class="constructor">Parameter()</span>获取请求数据。</span><br><span class="line">Controller的方法，添加对应表单字段name的参数，有几个表单字段就添加多少个对应的入参。</span><br><span class="line">Controller的方法，添加自定义Java类型的入参，并添加@ModelAttribute注解，由这个入参对象接收表单提交的数据。</span><br></pre></td></tr></table></figure><h5 id="9-动态sql"><a href="#9-动态sql" class="headerlink" title="9.动态sql"></a>9.动态sql</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、所谓<span class="keyword">SQL</span>的动态和静态，是指<span class="keyword">SQL</span>语句在何时被编译和执行，二者都是用在</span><br><span class="line"><span class="keyword">SQL</span>嵌入式编程中的，这里所说的嵌入式是指将<span class="keyword">SQL</span>语句嵌入在高级语言</span><br><span class="line">中，而不是针对于单片机的那种嵌入式编程。</span><br><span class="line"><span class="number">2</span>、<span class="keyword">SQL</span>语句的主体结构，在编译时尚无法确定，只有等到程序运行起来，在执</span><br><span class="line">行的过程中才能确定，这种<span class="keyword">SQL</span>叫做动态<span class="keyword">SQL</span>。</span><br><span class="line"><span class="number">3</span>、静态<span class="keyword">SQL</span>语句的编译是在应用程序运行前进行的，编译的结果会存储在数据</span><br><span class="line">库内部。而程序运行时，数据库将直接执行编译好的<span class="keyword">SQL</span>语句，降低运行时的</span><br><span class="line">开销。</span><br></pre></td></tr></table></figure><h5 id="10-Mybatis-中Mapper2动态代理规范是什么？"><a href="#10-Mybatis-中Mapper2动态代理规范是什么？" class="headerlink" title="10.Mybatis!中Mapper2动态代理规范是什么？"></a>10.Mybatis!中Mapper2动态代理规范是什么？</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、<span class="type">xml</span>映射文件中的namespace.与mapper接口的全类名相同。</span><br><span class="line"><span class="number">2</span>、Mapper接口方法名和<span class="type">xml</span>映射文件中定义的每个<span class="keyword">statement</span>的id相同。</span><br><span class="line"><span class="number">3</span>、Mapper接口方法的输入参数类型和<span class="type">xml</span>映射文件中定义的每个<span class="keyword">sql</span>的param-eterType的类型相同。</span><br><span class="line"><span class="number">4</span>、Mapper:接口方法的输出参数类型和<span class="type">xml</span>映射文件中定义的每个<span class="keyword">sql</span>的result-<span class="keyword">Type</span>的类型相同。</span><br></pre></td></tr></table></figure><h5 id="11-说说你比较熟悉的设计模式及应用场景？"><a href="#11-说说你比较熟悉的设计模式及应用场景？" class="headerlink" title="11.说说你比较熟悉的设计模式及应用场景？"></a>11.说说你比较熟悉的设计模式及应用场景？</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">单例模式：保证一个类仅有一个实例，并提供一个全局访问点，比如一些配置</span><br><span class="line">文件或者管理类可以设计为单例，我们常用的线程池也是单例的</span><br><span class="line">模板方法：在定义好的算法骨架下，允许子类为一个或多个步骤提供实现，一</span><br><span class="line">次性实现算法的不变部分，将可变部分留给子类实现，当子类实现代码逻辑雷</span><br><span class="line">同时，可以使用此设计模式</span><br><span class="line">工厂方法：创建对象需要大量的重复代码时，通过子类实现方法来创建对象。</span><br><span class="line">如Spring中通过工厂模式将创建对象的任务交给容器管理。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloudAlibaba</title>
      <link href="/2023/04/02/23.SpringCloudAlibaba/"/>
      <url>/2023/04/02/23.SpringCloudAlibaba/</url>
      
        <content type="html"><![CDATA[<p>1.Nacos<br>注册中心&#x2F;配置中心&#x2F;服务管理平台</p><p>CP  AP(主流)<br>CAP<br>C：一致性 （注册中心主从结构）<br>A：可用性<br>P：分区容错性</p><p>2.ribbin<br>随机<br>轮询<br>加权轮询<br>最小连接数<br>ip hash</p><p>3.openfeign<br>http调用</p><p>4.config<br>时效性&#x2F;安全性&#x2F;维护性</p><ol start="5"><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloudAlibaba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2023/04/02/22.Elasticsearch/"/>
      <url>/2023/04/02/22.Elasticsearch/</url>
      
        <content type="html"><![CDATA[<p>Elasticsearch是一种开源的分布式搜索引擎，提供了全文搜索、聚合分析和实时数据分析等功能。Elasticsearch提供了多种API供开发者使用，以下是Elasticsearch的增删改查操作示例：</p><ol><li>增加操作：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">indexDocument</span>(<span class="title class_">String</span> indexName, <span class="title class_">String</span> documentId, <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; <span class="variable language_">document</span>) throws <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="title class_">IndexRequest</span> request = <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(indexName).<span class="title function_">id</span>(documentId).<span class="title function_">source</span>(<span class="variable language_">document</span>);</span><br><span class="line">    <span class="title class_">IndexResponse</span> response = client.<span class="title function_">index</span>(request, <span class="title class_">RequestOptions</span>.<span class="property">DEFAULT</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>删除操作：</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">deleteDocument</span><span class="params">(<span class="type">String</span> indexName, <span class="type">String</span> documentId)</span> throws IOException </span>&#123;</span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> <span class="built_in">DeleteRequest</span>(indexName, documentId);</span><br><span class="line">    DeleteResponse response = client.<span class="built_in">delete</span>(request, RequestOptions.<span class="literal">DEFAULT</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改操作：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">updateDocument</span>(<span class="title class_">String</span> indexName, <span class="title class_">String</span> documentId, <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">Object</span>&gt; <span class="variable language_">document</span>) throws <span class="title class_">IOException</span> &#123;</span><br><span class="line">    <span class="title class_">UpdateRequest</span> request = <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(indexName, documentId).<span class="title function_">doc</span>(<span class="variable language_">document</span>);</span><br><span class="line">    <span class="title class_">UpdateResponse</span> response = client.<span class="title function_">update</span>(request, <span class="title class_">RequestOptions</span>.<span class="property">DEFAULT</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询操作：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Map&lt;String, Object&gt;&gt; search<span class="constructor">Documents(String <span class="params">indexName</span>, QueryBuilder <span class="params">queryBuilder</span>)</span> throws IOException &#123;</span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> <span class="constructor">SearchRequest(<span class="params">indexName</span>)</span>.source(<span class="keyword">new</span> <span class="constructor">SearchSourceBuilder()</span>.query(queryBuilder));</span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; documents = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>stream(response.get<span class="constructor">Hits()</span>.get<span class="constructor">Hits()</span>)</span><br><span class="line">            .map(hit -&gt; hit.get<span class="constructor">SourceAsMap()</span>)</span><br><span class="line">            .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br><span class="line">    return documents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例使用了QueryBuilder构建查询条件，并使用SearchSourceBuilder将查询条件传递给SearchRequest。可以通过其他API获取索引的状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JdbcTemplate</title>
      <link href="/2023/04/02/21.JdbcTemplate/"/>
      <url>/2023/04/02/21.JdbcTemplate/</url>
      
        <content type="html"><![CDATA[<h5 id="JdbcTemplate是Spring框架提供的一个JDBC操作工具类，可以简化JDBC操作，以下是JdbcTemplate的增删改查操作示例："><a href="#JdbcTemplate是Spring框架提供的一个JDBC操作工具类，可以简化JDBC操作，以下是JdbcTemplate的增删改查操作示例：" class="headerlink" title="JdbcTemplate是Spring框架提供的一个JDBC操作工具类，可以简化JDBC操作，以下是JdbcTemplate的增删改查操作示例："></a>JdbcTemplate是Spring框架提供的一个JDBC操作工具类，可以简化JDBC操作，以下是JdbcTemplate的增删改查操作示例：</h5><ol><li>增加操作：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span> <span class="keyword">add</span>(<span class="keyword">User</span> <span class="keyword">user</span>) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;INSERT INTO user (name, age) VALUES (?, ?)&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.<span class="keyword">update</span>(<span class="keyword">sql</span>, <span class="keyword">user</span>.getName(), <span class="keyword">user</span>.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>删除操作：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span> deleteById(<span class="type">int</span> id) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;DELETE FROM user WHERE id = ?&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.<span class="keyword">update</span>(<span class="keyword">sql</span>, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改操作：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span> <span class="keyword">update</span>(<span class="keyword">User</span> <span class="keyword">user</span>) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;UPDATE user SET name = ?, age = ? WHERE id = ?&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.<span class="keyword">update</span>(<span class="keyword">sql</span>, <span class="keyword">user</span>.getName(), <span class="keyword">user</span>.getAge(), <span class="keyword">user</span>.getId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询操作：</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> getById(<span class="type">int</span> id) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;SELECT * FROM user WHERE id = ?&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="keyword">sql</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;id&#125;, <span class="built_in">new</span> BeanPropertyRowMapper&lt;&gt;(<span class="keyword">User</span>.<span class="keyword">class</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，BeanPropertyRowMapper用于将查询结果映射成Java对象。</p><h5 id="jdbctemplate的查询操作"><a href="#jdbctemplate的查询操作" class="headerlink" title="jdbctemplate的查询操作"></a>jdbctemplate的查询操作</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate是Spring框架提供的一个JDBC操作工具类，可以简化JDBC操作，以下是JdbcTemplate的查询操作示例：</span><br><span class="line"></span><br><span class="line">查询单行数据：</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> getById(<span class="type">int</span> id) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;SELECT * FROM user WHERE id = ?&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="keyword">sql</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;id&#125;, <span class="built_in">new</span> BeanPropertyRowMapper&lt;&gt;(<span class="keyword">User</span>.<span class="keyword">class</span>));</span><br><span class="line">&#125;</span><br><span class="line">其中，BeanPropertyRowMapper用于将查询结果映射成Java对象。</span><br><span class="line"></span><br><span class="line">查询多行数据：</span><br><span class="line"><span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; getAll() &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;SELECT * FROM user&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(<span class="keyword">sql</span>, <span class="built_in">new</span> BeanPropertyRowMapper&lt;&gt;(<span class="keyword">User</span>.<span class="keyword">class</span>));</span><br><span class="line">&#125;</span><br><span class="line">查询单个值：</span><br><span class="line"><span class="built_in">public</span> <span class="type">int</span> getCount() &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;SELECT COUNT(*) FROM user&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="keyword">sql</span>, <span class="type">Integer</span>.<span class="keyword">class</span>);</span><br><span class="line">&#125;</span><br><span class="line">执行自定义的<span class="keyword">SQL</span>语句：</span><br><span class="line"><span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; getByAge(<span class="type">int</span> age) &#123;</span><br><span class="line">    String <span class="keyword">sql</span> = &quot;SELECT * FROM user WHERE age = ?&quot;;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(<span class="keyword">sql</span>, <span class="built_in">new</span> <span class="keyword">Object</span>[]&#123;age&#125;, <span class="built_in">new</span> BeanPropertyRowMapper&lt;&gt;(<span class="keyword">User</span>.<span class="keyword">class</span>));</span><br><span class="line">&#125;</span><br><span class="line">以上示例均使用了BeanPropertyRowMapper将查询结果映射成Java对象，也可以使用其他的RowMapper实现自定义映射逻辑。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JdbcTemplate </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JdbcTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB</title>
      <link href="/2023/04/02/20.MongoDB/"/>
      <url>/2023/04/02/20.MongoDB/</url>
      
        <content type="html"><![CDATA[<p>MongoDB是一种基于文档的NoSQL数据库，以JSON格式存储数据，并提供了灵活的查询和聚合功能。MongoDB提供了多种API供开发者使用，以下是MongoDB的增删改查操作示例：</p><ol><li>增加操作：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void insert<span class="constructor">Document(String <span class="params">collectionName</span>, Document <span class="params">document</span>)</span> &#123;</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.get<span class="constructor">Collection(<span class="params">collectionName</span>)</span>;</span><br><span class="line">    collection.insert<span class="constructor">One(<span class="params">document</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>删除操作：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void delete<span class="constructor">Document(String <span class="params">collectionName</span>, Bson <span class="params">filter</span>)</span> &#123;</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.get<span class="constructor">Collection(<span class="params">collectionName</span>)</span>;</span><br><span class="line">    collection.delete<span class="constructor">Many(<span class="params">filter</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改操作：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void update<span class="constructor">Document(String <span class="params">collectionName</span>, Bson <span class="params">filter</span>, Bson <span class="params">update</span>)</span> &#123;</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.get<span class="constructor">Collection(<span class="params">collectionName</span>)</span>;</span><br><span class="line">    collection.update<span class="constructor">Many(<span class="params">filter</span>, <span class="params">update</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询操作：</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Document&gt; find<span class="constructor">Documents(String <span class="params">collectionName</span>, Bson <span class="params">filter</span>)</span> &#123;</span><br><span class="line">    MongoCollection&lt;Document&gt; collection = database.get<span class="constructor">Collection(<span class="params">collectionName</span>)</span>;</span><br><span class="line">    FindIterable&lt;Document&gt; iterable = collection.find(filter);</span><br><span class="line">    List&lt;Document&gt; documents = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    iterable.<span class="keyword">for</span><span class="constructor">Each(<span class="params">documents</span>::<span class="params">add</span>)</span>;</span><br><span class="line">    return documents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例使用了Bson构建查询条件，并使用FindIterable获取查询结果。可以通过其他API获取数据库和集合的状态信息。</p>]]></content>
      
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON</title>
      <link href="/2023/03/26/19.JSON/"/>
      <url>/2023/03/26/19.JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="JSONObject和JSONArray区别及基本用法"><a href="#JSONObject和JSONArray区别及基本用法" class="headerlink" title="JSONObject和JSONArray区别及基本用法"></a>JSONObject和JSONArray区别及基本用法</h1><h2 id="一、JSONObject和JSONArray的数据表示形式"><a href="#一、JSONObject和JSONArray的数据表示形式" class="headerlink" title="一、JSONObject和JSONArray的数据表示形式"></a>一、JSONObject和JSONArray的数据表示形式</h2><p>JSONObject的数据是用 {  } 来表示的，</p><p>例如:<br>{ “id” : “123”, “courseID” : “huangt-test”, “title” : “提交作业”, “content” : null  }</p><p>而JSONArray，顾名思义是由JSONObject构成的数组，用  [ { } , { } , ……  , { } ]  来表示</p><p>例如:<br>[ {  “id” : “123”, “courseID” : “huangt-test”, “title” : “提交作业” },<br>{  “content” : null, “beginTime” : 1398873600000  “endTime” } ]</p><p>表示了包含2个JSONObject的JSONArray</p><p>可以看到一个很明显的区别，一个用的是 { }  ，一个最外面用的是 [ ]</p><h2 id="二、如何从字符串String获得JSONObject对象和JSONArray对象"><a href="#二、如何从字符串String获得JSONObject对象和JSONArray对象" class="headerlink" title="二、如何从字符串String获得JSONObject对象和JSONArray对象"></a>二、如何从字符串String获得JSONObject对象和JSONArray对象</h2><p>JSONObject  jsonObject  &#x3D; new JSONObject (String str);</p><p>JSONArray jsonArray &#x3D; new JSONArray(String str) ;</p><h2 id="三、如何从JSONArray中获得JSONObject对象"><a href="#三、如何从JSONArray中获得JSONObject对象" class="headerlink" title="三、如何从JSONArray中获得JSONObject对象"></a>三、如何从JSONArray中获得JSONObject对象</h2><p>大家可以把JSONArray当成一般的数组来对待，只是获取的数据内数据的方法不一样</p><p>JSONObject   jsonObject &#x3D; (JSONObject)jsonArray.get(i);<br>JSONObject   jsonObject  &#x3D;  jsonArray.getJSONObject(i);  </p><p>两者都可。第一种注意转换</p><h2 id="四、获取JSON内的数据"><a href="#四、获取JSON内的数据" class="headerlink" title="四、获取JSON内的数据"></a>四、获取JSON内的数据</h2><p>int jid &#x3D; jsonObject.getInt ( “id” ) ;&#x2F;&#x2F;这里的jid得到的数据就是123.</p><p>String  jcourse&#x3D;jsonObject.getString( “ courseID”) ;&#x2F;&#x2F;这里的jcourse得到的数据就是huangt-test</p><p>Strirng jcourse &#x3D; jsonObject.get(“courseID”).toString();</p><h2 id="五、一般为键值对"><a href="#五、一般为键值对" class="headerlink" title="五、一般为键值对"></a>五、一般为键值对</h2><p>eg:{  name:”xm”, value:”张三”}</p><p>  String jname &#x3D; null;</p><p>  if(jsonObject.get(“name”).equals(“xm”)){</p><p>  jname&#x3D;jsonObject.get(“value”).toString();</p><p>}</p>]]></content>
      
      
      <categories>
          
          <category> JSON </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="/2023/03/23/18.%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/03/23/18.%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h1 id="SQl"><a href="#SQl" class="headerlink" title="SQl"></a>SQl</h1><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p><h2 id="数据库三大范式是什么？"><a href="#数据库三大范式是什么？" class="headerlink" title="数据库三大范式是什么？"></a>数据库三大范式是什么？</h2><p>第一范式：每个列都不可以再拆分。<br>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。<br>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><h2 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h2><p>Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。<br>MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</p><h2 id="MyISAM索引与InnoDB索引的区别？"><a href="#MyISAM索引与InnoDB索引的区别？" class="headerlink" title="MyISAM索引与InnoDB索引的区别？"></a>MyISAM索引与InnoDB索引的区别？</h2><p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。<br>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。<br>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。<br>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p><h2 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h2><p>MyISAM：以读写插入为主<br>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键</p><h2 id="索引有哪几种类型？"><a href="#索引有哪几种类型？" class="headerlink" title="索引有哪几种类型？"></a>索引有哪几种类型？</h2><ul><li>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</li><li>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。<br>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引<br>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2);创建唯一组合索引</li><li>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。<br>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引<br>可以通过ALTER TABLE table_name ADD INDEX index_name(column1,column2, column3);创建组合索引</li><li>全文索引： 是目前搜索引擎使用的一种关键技术。<br>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li></ul><p>根据实际的需要选择合适的存储引擎<br>存储引擎：指定了表的类型，表的存储方式，索引数据，是不是支持事务</p>]]></content>
      
      
      <categories>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/03/23/17.JVM/"/>
      <url>/2023/03/23/17.JVM/</url>
      
        <content type="html"><![CDATA[<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝和深拷贝是两种不同的对象拷贝方式。</p><p>浅拷贝是指创建一个新的对象，这个对象有着原始对象属性的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。<br>深拷贝是指创建一个新的对象，这个对象有着原始对象属性的一份精确拷贝，并且拷贝的对象的属性也是完全拷贝的，而不是引用。因此，如果其中一个对象改变了这个地址，不会影响到另一个对象。</p><h2 id="说一下堆栈的区别？"><a href="#说一下堆栈的区别？" class="headerlink" title="说一下堆栈的区别？"></a>说一下堆栈的区别？</h2><p>堆：用于存储动态分配的内存，即使用new等关键字动态创建的对象。堆的特点是可以任意分配和释放内存，不会出现“内存碎片”的问题，但是分配和释放的速度相对较慢，需要程序员手动管理内存。<br>栈：用于存储局部变量和函数调用的上下文。栈的特点是存储速度快，由于栈空间是连续的，因此分配和释放内存非常快，但是栈的大小是固定的，不支持动态扩展，在函数调用过程中可能会出现“栈溢出”的问题。</p><h2 id="简述Java垃圾回收机制"><a href="#简述Java垃圾回收机制" class="headerlink" title="简述Java垃圾回收机制"></a>简述Java垃圾回收机制</h2><p>在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。</p><h2 id="Java-中都有哪些引用类型？"><a href="#Java-中都有哪些引用类型？" class="headerlink" title="Java 中都有哪些引用类型？"></a>Java 中都有哪些引用类型？</h2><p>强引用：发生 gc 的时候不会被回收。<br>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。<br>弱引用：有用但不是必须的对象，在下一次GC时会被回收。<br>虚引用（幽灵引用&#x2F;幻影引用）：无法通过虚引用获得对象，用PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p><h2 id="说一下-JVM-有哪些垃圾回收算法？"><a href="#说一下-JVM-有哪些垃圾回收算法？" class="headerlink" title="说一下 JVM 有哪些垃圾回收算法？"></a>说一下 JVM 有哪些垃圾回收算法？</h2><ul><li>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</li><li>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。（包括年轻代、老年代和永久代）</li></ul><h2 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h2><p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><p>对象优先在 Eden 区分配<br>大对象直接进入老年代<br>长期存活对象将进入老年代</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>说一下 JVM 调优的工具？<br>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是<br>jconsole 和 jvisualvm 这两款视图监控工具<br>jconsole：用于对 JVM 中的内存、线程和类等进行监控<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc变化</p><h2 id="常用的-JVM-调优的参数都有哪些？"><a href="#常用的-JVM-调优的参数都有哪些？" class="headerlink" title="常用的 JVM 调优的参数都有哪些？"></a>常用的 JVM 调优的参数都有哪些？</h2><p>-Xms2g：初始化堆大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio&#x3D;4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio&#x3D;8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。<br>当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。</p><h3 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h3><ul><li>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME&#x2F;lib&#x2F;目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</li><li>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</li><li>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</li><li>自定义类加载器</li></ul><h2 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h2><p>类装载分为以下 5 个步骤：</p><ul><li>加载：根据查找路径找到相应的 class 文件然后导入；</li><li>验证：检查加载的 class 文件的正确性；</li><li>准备：给类中的静态变量分配内存空间；</li><li>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；</li><li>初始化：对静态变量和静态代码块执行初始化工作。</li></ul><h2 id="什么是类加载器，类加载器有哪些"><a href="#什么是类加载器，类加载器有哪些" class="headerlink" title="什么是类加载器，类加载器有哪些?"></a>什么是类加载器，类加载器有哪些?</h2><p>实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。<br>主要有一下四种类加载器:</p><ol><li>启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被<br>java程序直接引用。</li><li>扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。<br>Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找<br>并加载 Java 类。</li><li>系统类加载器（system class loader）：它根据 Java 应用的类路径<br>（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来<br>完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取<br>它。</li><li>用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实<br>现。</li></ol><h2 id="描述一下JVM加载Class文件的原理机制"><a href="#描述一下JVM加载Class文件的原理机制" class="headerlink" title="描述一下JVM加载Class文件的原理机制"></a>描述一下JVM加载Class文件的原理机制</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。<br>类装载方式，有两种 ：<br>1.隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，<br>2.显式装载， 通过class.forname()等方法，显式加载需要的类Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h2 id="简述java类加载机制"><a href="#简述java类加载机制" class="headerlink" title="简述java类加载机制?"></a>简述java类加载机制?</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity</title>
      <link href="/2023/03/23/16.SpringSecurity/"/>
      <url>/2023/03/23/16.SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="Web应用的安全性包括用户认证-Authentication-和用户授权-Authorization-两个部分。"><a href="#Web应用的安全性包括用户认证-Authentication-和用户授权-Authorization-两个部分。" class="headerlink" title="Web应用的安全性包括用户认证(Authentication)和用户授权(Authorization)两个部分。"></a>Web应用的安全性包括用户认证(Authentication)和用户授权(Authorization)两个部分。</h1><p>(1)用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码。系统通过校验用户名和密码来完成认证过程。<br>(2)用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件。来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。</p><h1 id="Spring-Security-其实就是用filter-多请求的路径进行过滤。"><a href="#Spring-Security-其实就是用filter-多请求的路径进行过滤。" class="headerlink" title="Spring Security:其实就是用filter,多请求的路径进行过滤。"></a>Spring Security:其实就是用filter,多请求的路径进行过滤。</h1><p>(1)如果是基于Session,那么Spring-security会对cookie里的sessionid进行解析，找到服务器存储的session信息，然后判断当前用户是否符合请求的要求。<br>(2)如果是token,则是解析出token,然后将当前请求加入到Spring-security管理的权限信息中去</p><h1 id="认证与授权实现思路："><a href="#认证与授权实现思路：" class="headerlink" title="认证与授权实现思路："></a>认证与授权实现思路：</h1><p>如果系统的模块众多，每个模块都需要进行授权与认证，所以我们选择基于tokn的形式进行授权与认证，用户根据用户名密码认证成功，然后获取当前用户角色的一系列权限值，并以用户名为key,权限列表为value的形式存入redis缓存中，根据用户名相关信息生成token返回，浏览器将token记录到cookie中，每次调用api接口都默认将token携带到header请求头中，Spring-security解析header头获取token信息，解析token获取当前用户名，根据用户名就可以从redis中获取权限列表，这样Spring-security就能够判断当前请求是否有权限访问</p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2023/03/19/15.%E7%AE%97%E6%B3%95/"/>
      <url>/2023/03/19/15.%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void <span class="keyword">bubbleSort(int[] </span>arr) &#123;</span><br><span class="line">        int n = arr.length;</span><br><span class="line">        for (int i = <span class="number">0</span><span class="comment">; i &lt; n-1; i++) &#123;</span></span><br><span class="line">            for (int <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; n-i-1; j++) &#123;</span></span><br><span class="line">                if (arr[<span class="keyword">j] </span>&gt; arr[<span class="keyword">j+1]) </span>&#123;</span><br><span class="line">                    int temp = arr[<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"></span>                    arr[<span class="keyword">j] </span>= arr[<span class="keyword">j+1];</span></span><br><span class="line"><span class="keyword"></span>                    arr[<span class="keyword">j+1] </span>= temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性</title>
      <link href="/2023/03/19/14.JDK8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2023/03/19/14.JDK8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8新特性："><a href="#JDK8新特性：" class="headerlink" title="JDK8新特性："></a>JDK8新特性：</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.L</span>ambda表达式</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>新的日期API</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>引入Optional</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>使用Base64</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>接口的默认方法和静态方法</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>新增方法引用格式</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>新增<span class="built_in">Stream</span>类</span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>注解相关的改变</span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>支持并行（parallel）数组</span><br><span class="line"></span><br><span class="line"><span class="number">10.</span>对并发类（Concurrency）的扩展。</span><br></pre></td></tr></table></figure><h1 id="1-判空"><a href="#1-判空" class="headerlink" title="1.判空"></a>1.判空</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">object</span> == <span class="keyword">null</span></span><br><span class="line">如果仅判断该对象、集合是否被分配内存(即<span class="keyword">null</span>还是非<span class="keyword">null</span>)，而不用考虑是否有值，直接使用<span class="keyword">object</span>==<span class="keyword">null</span>判断</span><br><span class="line"><span class="number">2.</span>对象为空</span><br><span class="line">StringUtils.isEmpty()   cs == <span class="keyword">null</span> || cs.length() == <span class="number">0</span></span><br><span class="line"><span class="number">3.</span>字符为空</span><br><span class="line">如将值或元素不存在也看作为空，如果是简单的String，则使用lang3或spring下的StringUtils.isEmpty()</span><br><span class="line"><span class="number">4.</span>集合为空</span><br><span class="line">springframework提供的CollectionUtils.isEmpty()</span><br></pre></td></tr></table></figure><h1 id="2-Stream"><a href="#2-Stream" class="headerlink" title="2.Stream"></a>2.Stream</h1><p>Arrays.asList(): 数组转化成List集合</p><p>Stream的获取<br>① 通过集合Collection获取</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">List</span>&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"><span class="attribute">Stream</span>&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure><p>② 通过数组获取</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[]<span class="built_in"> array </span>= &#123;<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;ok&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(array);</span><br><span class="line">//对于基本类型数组的处理</span><br><span class="line">int[]<span class="built_in"> array </span>= &#123;1,2,3,4,5&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(array).boxed();    </span><br><span class="line">//Arrays.stream(array)获取的是一个IntStream对象，boxed 方法用于将目前 Stream 中的基本类型装箱</span><br></pre></td></tr></table></figure><p>③ 直接通过值获取</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stream</span>&lt;<span class="type">String</span>&gt; stream = <span class="built_in">Stream</span>.<span class="built_in">of</span>(<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;ok&quot;</span>);</span><br></pre></td></tr></table></figure><p>1.筛选 filter</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//筛选出列表中的非空项</span></span><br><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;ok&quot;</span>)</span>;</span><br><span class="line">List&lt;String&gt; filted = <span class="built_in">list</span>.stream<span class="literal">()</span></span><br><span class="line">                      .filter(x-&gt; !x.empty<span class="literal">()</span>)</span><br><span class="line">                      .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br></pre></td></tr></table></figure><p>2.去重 distinct</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//去除列表中的重复元素</span></span><br><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;ok&quot;</span>)</span>;</span><br><span class="line">List&lt;String&gt; distincted = <span class="built_in">list</span>.stream<span class="literal">()</span></span><br><span class="line">                          .distinct<span class="literal">()</span></span><br><span class="line">                          .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br></pre></td></tr></table></figure><p>3.截取 limit</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Stream的前3个值</span></span><br><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;fucking&quot;</span>,<span class="string">&quot;ok&quot;</span>)</span>;</span><br><span class="line">List&lt;String&gt; distincted = <span class="built_in">list</span>.stream<span class="literal">()</span></span><br><span class="line">                          .limit(<span class="number">3</span>);</span><br><span class="line">                          .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br></pre></td></tr></table></figure><p>4.跳过 skip</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="string">&quot;are&quot;</span>,<span class="string">&quot;you&quot;</span>,<span class="string">&quot;fucking&quot;</span>,<span class="string">&quot;ok&quot;</span>)</span>;</span><br><span class="line">List&lt;String&gt; distincted = <span class="built_in">list</span>.stream<span class="literal">()</span></span><br><span class="line">                          .skip(<span class="number">2</span>);</span><br><span class="line">                          .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br></pre></td></tr></table></figure><p>5.映射 map</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将集合中的每一个元素+1，并转为字符串</span></span><br><span class="line">List&lt;Integer&gt; <span class="built_in">list</span> = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(1,2,3,4,5)</span>;</span><br><span class="line">List&lt;String&gt; result = <span class="built_in">list</span>.stream<span class="literal">()</span></span><br><span class="line">                      .map(x-&gt;<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="operator">++</span><span class="params">x</span>)</span>)</span><br><span class="line">                      .collect(<span class="module-access"><span class="module"><span class="identifier">Collectors</span>.</span></span><span class="keyword">to</span><span class="constructor">List()</span>);</span><br><span class="line"><span class="comment">//统计集合中&gt;3的元素数量</span></span><br><span class="line"><span class="built_in">int</span> result = <span class="built_in">list</span>.stream<span class="literal">()</span>.filter(x -&gt; x &gt; <span class="number">3</span>).count<span class="literal">()</span>;</span><br></pre></td></tr></table></figure><p>6.合并多个流 flatMap</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="operator">.....</span></span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="operator">...</span></span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;&gt;</span> <span class="variable">list</span> <span class="operator">=</span> <span class="built_in">Arrays</span><span class="operator">.</span><span class="variable">asList</span><span class="punctuation">(</span><span class="variable">list1</span><span class="operator">,</span><span class="variable">list2</span><span class="punctuation">)</span><span class="operator">;</span> </span><br><span class="line"><span class="operator">//</span>将<span class="variable">list</span>中的<span class="variable">list1</span>，<span class="variable">list2</span>合并为一个<span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span></span><br><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">listsum</span> <span class="operator">=</span> <span class="variable">list</span><span class="operator">.</span><span class="variable">stream</span><span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">                           <span class="operator">.</span><span class="variable">flatMap</span><span class="punctuation">(</span><span class="built_in">List</span><span class="string">::stream</span><span class="punctuation">)</span></span><br><span class="line">                           <span class="operator">.</span><span class="variable">collect</span><span class="punctuation">(</span><span class="variable">Collectors</span><span class="operator">.</span><span class="variable">toList</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2023/03/19/13.%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/03/19/13.%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h1><ul><li><p>进程是程序在计算机上的一次执行活动（当你运行一个程序，你就启动了一个进程）</p></li><li><p>线程是进程中的实际运行单位，是独立运行于进程之中的子任务。是操作系统进行运算调度的最小单位。进程就是有一个或多个线程构成的。可理解为线程是进程中的一个最小运行单元，进程中的一个执行路径。</p></li></ul><p>我们初学 java 边写代码的时候，通常使用 main 方法进行运行，此时 main 方法执行的便是一个主线程，而所谓的多线程，即是在主线程执行的过程中，同时执行其他的线程。但是同时执行多个线程容易出现报错现象，例如同时同分同秒，两个线程同时修改一个 txt、数据库表文件，或第一个线程没有修改完 txt、数据库表文件，第二个线程同时也去修改。这便是线程之间的混乱、资源竞争、脏读，便是程序员需要去解决的疑难杂症。</p><h1 id="线程：分为守护线程和用户线程；"><a href="#线程：分为守护线程和用户线程；" class="headerlink" title="线程：分为守护线程和用户线程；"></a>线程：分为守护线程和用户线程；</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户线程：当一个进程不包含任何存活的用户线程时，进程结束；</span><br><span class="line">守护线程：守护用户线程的，当最后一个用户线程结束时，所有守护线程自动死亡。</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.继承Thread类，重写<span class="built_in">run</span>()</span><br><span class="line"><span class="number">2</span>.实现<span class="built_in">Runnable</span>()，重写<span class="built_in">run</span>(),将类名放入new <span class="built_in">Thread</span>()</span><br><span class="line"><span class="number">3</span>.实现Callable&lt;V&gt;接口，重写<span class="built_in">call</span>()</span><br></pre></td></tr></table></figure><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h1><p>分时调度<br>所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p><p>抢占式调度<br>优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调用。<br>CPU使用抢占式调度模式在多个线程间进行着高速的切换，对于CPU的一个核心而言，某个时刻，只能执行一个线程，而CPU在多个线程间切换的速度相对于我们的感觉要快，看上去就是在同一时刻运行。其实，多线程程序并不能提高程序的运行速度，但能提高程序的运行效率，让CPU的使用率更高。</p><h1 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h1><p>同步：排队执行，效率低但是安全。</p><p>异步：同时执行，效率高但是数据不安全。</p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>并发：指两个或多个事件在同一个时间段内发生。</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）。</p><h1 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h1><p>获取线程名称与设置线程名称:Thread.currentThread()   getName()、setName()<br>线程的休眠:sleep()<br>线程阻塞:所有消耗时间的操作\耗时操作<br>线程中断:中断标记 interrupt()<br>守护线程:setDaemon(true)</p><p>synchronized(线程同步)<br>线程同步有三种方式，三种加锁的方式。<br>1、同步代码块</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">synchronized</span><span class="params">(锁对象)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>2、同步方法<br>如果不是静态的（static）的同步方法，它的锁对象为this；如果是静态的同步方法，它的锁对象为类名.class，比如下方的例子中，如果是静态的，则锁对象为Ticket.class</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span></span>&#123;</span><br><span class="line">        Runnable run = <span class="keyword">new</span> <span class="built_in">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Thread</span>(run).<span class="built_in">start</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Thread</span>(run).<span class="built_in">start</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Thread</span>(run).<span class="built_in">start</span>();</span><br><span class="line">    <span class="comment">//new Thread(new Ticket()).start()//这里不是同一把锁，所以是同时执行（异步），不是排队执行（同步）了。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> implements Runnable&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">        @<span class="function">Override</span></span><br><span class="line"><span class="function">        <span class="keyword">public</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//synchronized()&#123;  &#125;//如果这里同步代码块和同步方法同时用了一把锁，那么一个线程执行同步方法活同步代码块时，其他线程对同步方法和同步代码块都不能执行。就好比商店里的试衣间，大门和试衣间的门用的是同一把锁，那么只要有一个人（线程）在使用其中的一个试衣间，那么其他人连大门都进不去，只能等待里面的人用完试衣间把锁打开。</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> flag = <span class="built_in">sale</span>();</span><br><span class="line">                <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.<span class="built_in">println</span>(<span class="string">&quot;正在准备卖票&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.<span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="built_in">catch</span>(InterruptedException e) &#123;</span><br><span class="line">                    e.<span class="built_in">printStackTrace</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.<span class="built_in">println</span>(Thread.<span class="built_in">currentThread</span>().<span class="built_in">getName</span>()+<span class="string">&quot;出票成功，余票：&quot;</span>+count);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、显示锁（Lock）<br>同步代码块和同步方法都属于隐式锁<br>显示锁Lock子类ReentrantLock</p><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>公平锁就是排队时谁先来，谁就先用这个锁。<br>非公平锁就是排队时抢着来，谁先抢到谁就用（Java线程同步的三种方式就是非公平锁）</p><p>在显示锁中定义时，构造函数的第一个参数设为true就是公平锁，false就是不公平锁</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock l = <span class="keyword">new</span> <span class="type">ReentrantLock</span>(<span class="literal">true</span>)<span class="comment">//fair参数设为true，就表示公平锁</span></span><br></pre></td></tr></table></figure><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>两个线程相互等待对方释放锁就造成了死锁。</p><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在线程的生命周期中：</span><br><span class="line">它要经过新建（<span class="keyword">New</span>）、就绪（Runnable）、运行（<span class="keyword">Running</span>）、阻塞（Blocked）和死亡（Dead）五种状态。</span><br><span class="line"></span><br><span class="line">新建 <span class="keyword">New</span></span><br><span class="line">就绪 Runnable</span><br><span class="line">运行 <span class="keyword">Running</span></span><br><span class="line">阻塞 Blocked</span><br><span class="line">死亡 Dead</span><br></pre></td></tr></table></figure><p>新建：start<br>就绪：获取cpu进行运行<br>运行：<br>  sleep，join，I&#x2F;O进入堵塞状态，结束后进入运行状态；<br>  synchronized进入锁状态，同步锁被释放后，进入就绪状态<br>  wait(),进入等待队列，通过notify、notifyAll、interrupt进入锁状态</p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud</title>
      <link href="/2023/03/18/12.SpringCloud/"/>
      <url>/2023/03/18/12.SpringCloud/</url>
      
        <content type="html"><![CDATA[<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Nacos</span></span><br><span class="line"><span class="attribute">Ribbon</span></span><br><span class="line"><span class="attribute">OpenFeign</span></span><br><span class="line"><span class="attribute">Sentine</span></span><br><span class="line"><span class="attribute">Gateway</span></span><br></pre></td></tr></table></figure><h5 id="feign远程调用"><a href="#feign远程调用" class="headerlink" title="feign远程调用"></a>feign远程调用</h5><p>Spring Cloud是一种基于Spring Boot的微服务架构，提供了服务发现、负载均衡、配置管理等功能。Spring Cloud提供了多种组件和API供开发者使用，以下是Spring Cloud的增删改查操作示例：</p><ol><li>增加操作：</li></ol><p>使用Feign客户端调用其他服务的API，以实现服务之间的通信和数据交互。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(name = <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">public interface UserServiceClient &#123;</span><br><span class="line">    <span class="variable">@PostMapping</span>(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    User <span class="built_in">createUser</span>(<span class="variable">@RequestBody</span> User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>删除操作：</li></ol><p>同样使用Feign客户端调用其他服务的API，以实现服务之间的通信和数据交互。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(name = <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">public interface UserServiceClient &#123;</span><br><span class="line">    <span class="variable">@DeleteMapping</span>(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class="line">    void <span class="built_in">deleteUser</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>修改操作：</li></ol><p>使用Feign客户端调用其他服务的API，以实现服务之间的通信和数据交互。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(name = <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">public interface UserServiceClient &#123;</span><br><span class="line">    <span class="variable">@PutMapping</span>(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class="line">    User <span class="built_in">updateUser</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) long id, <span class="variable">@RequestBody</span> User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>查询操作：</li></ol><p>使用Feign客户端调用其他服务的API，以实现服务之间的通信和数据交互。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(name = <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">public interface UserServiceClient &#123;</span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class="line">    User <span class="built_in">getUserById</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) long id);</span><br><span class="line">    </span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    List&lt;User&gt; <span class="built_in">getAllUsers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例使用了Feign客户端调用其他服务的API，也可以使用RestTemplate等方式实现服务之间的通信和数据交互。</p><p>好的，以下是使用Spring Cloud组件实现的示例：</p><ol><li>服务注册与发现</li></ol><p>使用Eureka Server实现服务注册与发现，将服务注册到Eureka Server中，其他服务可以通过Eureka Server发现并调用该服务。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableEurekaServer</span></span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务消费</li></ol><p>使用Feign客户端调用其他服务的API，以实现服务之间的通信和数据交互。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@FeignClient</span>(name = <span class="string">&quot;user-service&quot;</span>)</span><br><span class="line">public interface UserServiceClient &#123;</span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class="line">    User <span class="built_in">getUserById</span>(<span class="variable">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务路由</li></ol><p>使用Zuul网关实现服务路由，将请求路由到目标服务并返回响应结果。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableZuulProxy</span></span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>配置管理</li></ol><p>使用Spring Cloud Config实现配置管理，将配置信息存储在Git仓库中，并通过Config Server将配置信息提供给其他服务使用。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@EnableConfigServer</span></span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(ConfigServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例演示了使用Spring Cloud组件实现服务注册与发现、服务消费、服务路由和配置管理的功能。可以根据实际需求选择使用不同的组件。</p><ul><li>Nacos注册中心<br>作为服务与服务之间的一个通讯录,可以根据名称动态的获取ip和端口</li><li>Ribbon负载均衡<br>里面有三个策略,分别是轮询,随机,权重.通过这些策略就可以均衡分配请求</li><li>OpenFeign远程调用<br>微服务间的远程调用(项目内服务之间的调用,与Gateway无关)\</li><li>Sentine服务熔断降级<br>限流(通过监控QPS来限制访问的流量),<br>降级(当满足某些条件就进行熔断操作),来保证服务器不会因为超大的访问量冲垮</li><li>Gateway服务网关<br>客户端对项目服务的访问,与feign的内部调用不一样<br>网关的作用作为统一的入口,可以把一些通用的功能放到网关这里进行处理(登录拦截,验证,鉴权,限流)<br>在微服务项目中,存在多个服务,每个服务都分别部署在各种的服务器上,那就代表有多个访问地址.这样对于客户端的开发非常不友好,因为这样要记录很多访问地址,而且如果地址改变了就需要修改很多代码.<br>服务网关就可以解决这个问题,首先网关启动,会在注册中心注册,顺便带回一份最新的服务信息列表,那么当一个请求进入网关的时候,会带上路由规则,这个路由规则就是服务的名称,这时网关获取服务名与本地的服务信息列表对比,发现有对应的服务就会根据信息拼接url,在根据ribbon(feign)的负载均衡配置选择合适的节点,通过restTemplate对象发送一个http请求,访问该服务<br>其次还可以在网关配置过滤器filter做一些登录验证,鉴权等的统一功能.</li></ul><p>Gateway与Feign负载的区别?<br>gateway负载均衡是相对于请求的负载,对于web(客户端)请求进行负载,而feign是服务间调用的负载,服务间的限流<br>流程是:请求到gateway,gate通过路由请求到对应的服务,如果服务间有调用,使用feign进行服务间调用,然后数据原路返回web</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis概念</title>
      <link href="/2023/03/15/10.Redis%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/03/15/10.Redis%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis概念"><a href="#Redis概念" class="headerlink" title="Redis概念"></a>Redis概念</h1><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是一个高性能的 <span class="built_in">key</span>-value 数据库; Redis 是单进程单线程</span><br><span class="line">支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</span><br><span class="line"><span class="built_in">String</span>,list,<span class="built_in">set</span>,hash,zset</span><br></pre></td></tr></table></figure><h2 id="Redis结构用法"><a href="#Redis结构用法" class="headerlink" title="Redis结构用法"></a>Redis结构用法</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">String:</span>简单的键值对缓存</span><br><span class="line"><span class="symbol">List:</span>存储列表型的数据结构</span><br><span class="line"><span class="symbol">Set:</span>交集、并集、差集</span><br><span class="line"><span class="symbol">Hash:</span>对象</span><br><span class="line"><span class="symbol">ZSet:</span>去重且可排序[获取排名前几名的用户]</span><br><span class="line"></span><br><span class="line">Redis <span class="keyword">key</span>的过期时间和永久有效分别怎么设置:</span><br><span class="line">expire和persist命令</span><br></pre></td></tr></table></figure><h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将内存中的数据异步写入硬盘中，两种方式：RDB（默认）和 AOF</span><br><span class="line"></span><br><span class="line"><span class="number">4.0</span>开始允许使用RDB-AOF混合持久化的方式，结合了两者的优点，通过aof-<span class="keyword">use</span>-rdb-preamble配置项可以打开混合开关</span><br><span class="line"></span><br><span class="line">Redis 加载 RDB 恢复数据远远快于 AOF</span><br><span class="line"></span><br><span class="line">一份执行日志保存所有对redis进行更改的命令</span><br><span class="line">是一份内存快照保存了创建RDB文件那个时间点的redis全量数据</span><br><span class="line">先以RDB格式写入全量数据再追加增量日志</span><br></pre></td></tr></table></figure><h2 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis是个基于内存的缓存数据库，既然是基于内存的，那肯定就会有存满的时候</span><br><span class="line">如果真的存满了，再有新的数据过来肯定就存不进去了</span><br><span class="line">此时redis会执行既定的一些淘汰策略，本文大概讲一下redis六种淘汰策略</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span><span class="title function_">noeviction</span>(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>allkeys-lru：从所有<span class="built_in">key</span>中使用LRU算法进行淘汰（LRU算法：即最近最少使用算法）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>allkeys-<span class="built_in">random</span>：从所有<span class="built_in">key</span>中随机淘汰数据</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span><span class="keyword">volatile</span>-lru：从设置了过期时间的<span class="built_in">key</span>中使用LRU算法进行淘汰</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span><span class="keyword">volatile</span>-<span class="built_in">random</span>：从设置了过期时间的<span class="built_in">key</span>中随机淘汰</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span><span class="keyword">volatile</span>-ttl：在设置了过期时间的<span class="built_in">key</span>中，淘汰过期时间剩余最短的</span><br><span class="line"></span><br><span class="line">当使用<span class="keyword">volatile</span>-lru、<span class="keyword">volatile</span>-<span class="built_in">random</span>、<span class="keyword">volatile</span>-ttl这三种策略时，</span><br><span class="line">如果没有<span class="built_in">key</span>可以被淘汰，则和noeviction一样返回错误</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、获取当前内存淘汰策略：<span class="built_in"></span></span><br><span class="line"><span class="built_in">config </span><span class="built_in">get</span> maxmemory-policy</span><br><span class="line">2、获取Redis能使用的最大内存大小<span class="built_in"></span></span><br><span class="line"><span class="built_in">config </span><span class="built_in">get</span> maxmemory</span><br><span class="line">3、通过命令修改淘汰策略：<span class="built_in"></span></span><br><span class="line"><span class="built_in">config </span><span class="built_in">set</span> maxmemory-policy allkeys-lru</span><br><span class="line">4、设置Redis最大占用内存大小<span class="built_in"></span></span><br><span class="line"><span class="built_in">config </span><span class="built_in">set</span> maxmemory 100mb</span><br></pre></td></tr></table></figure><h2 id="Redis-过期键的删除策略"><a href="#Redis-过期键的删除策略" class="headerlink" title="Redis 过期键的删除策略"></a><strong>Redis 过期键的删除策略</strong></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer.让定时器在键的过期时间来临时，</span></span><br><span class="line">立即执行对键的删除操作。</span><br><span class="line"><span class="section">2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期</span></span><br><span class="line">的话，就删除该键;如果没有过期，就返回该键。</span><br></pre></td></tr></table></figure><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用setNx命令实现分布式锁。</span><br><span class="line">当且仅当key不存在，将key的值设为value。若给定的key已经存在，则setNx不做任何动作</span><br><span class="line">SETNX是『<span class="keyword">SET</span> if <span class="comment">Not eXists</span>』<span class="comment">(</span>如果不存在，则<span class="comment">SET)</span>的简写。</span><br><span class="line">返回值：设置成功，返回1。设置失败，返回0。</span><br><span class="line"></span><br><span class="line"><span class="comment">*单机锁JVM:项目简单，单机部署，无集群</span></span><br><span class="line">1.Synchronized关键字</span><br><span class="line">2.ReentrantLock对象</span><br><span class="line"></span><br><span class="line"><span class="comment">*分布式锁:</span></span><br><span class="line">setnx:如果key不存在，就创建，否则失败</span><br><span class="line">1.使用递归判断</span><br><span class="line">2.for循环判断</span><br><span class="line">3.Redisson分布式锁</span><br><span class="line"></span><br><span class="line"><span class="comment">*防死锁</span></span><br><span class="line">添加过期时间</span><br><span class="line">一行redis命令解决expire</span><br><span class="line">目的是保证原子性</span><br><span class="line"><span class="comment">*防误删</span></span><br><span class="line">利用线程ID或UUID给锁命名，删除前判断是不是自己的锁</span><br><span class="line"></span><br><span class="line">Redisson分布式锁-框架</span><br><span class="line">Redisson,是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的ava常用对象,还</span><br><span class="line">提供了许多分布式服务。</span><br><span class="line">Jedis侧重于对Redis的增删改查，而Redisson侧重于职责分离。</span><br><span class="line">四层保护:防死锁、防误删、可重入、自动续期</span><br><span class="line">1.导入maven依赖</span><br><span class="line">2.配置客户端Bean</span><br><span class="line">3.lock  <span class="comment">unlock</span></span><br><span class="line"></span><br><span class="line">1.为什么用分布式锁</span><br><span class="line">分布式锁主要用来解决集群部署下的数据安全问题</span><br><span class="line">集群部署情况下，单机锁无法保证外部资源的访问安全性</span><br><span class="line"></span><br><span class="line">2.Rediss分布式锁怎么防止死锁问题</span><br><span class="line">解释什么情况下会产生分布式锁中的死锁</span><br><span class="line">解决方案：设置过期时间expire（+自动续期)</span><br><span class="line"></span><br><span class="line">3.Redis分布式锁怎么防止误删</span><br><span class="line">什么情况下会产生分布式锁中的误删？</span><br><span class="line">解决方案：使用UUID设置锁的value,删之前判断一下</span><br><span class="line"></span><br><span class="line">如果追求高并发和性能，推荐Redis:分布式锁</span><br><span class="line">Redisson底层是用LUA脚本来实现原子性的</span><br></pre></td></tr></table></figure><h2 id="Redis缓存穿透、击穿、雪崩"><a href="#Redis缓存穿透、击穿、雪崩" class="headerlink" title="Redis缓存穿透、击穿、雪崩"></a>Redis缓存穿透、击穿、雪崩</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">什么是缓存穿透？</span><br><span class="line">我们使用Redis大部分情况都是通过Key查询对应的值，假如发送的请求传进来的<span class="type">key</span>是不存在Redis中的，那么就查不到缓存，查不到缓存就会去数据库查询。假如有大量这样的请求，这些请求像“穿透”了缓存一样直接打在数据库上，这种现象就叫做缓存穿透。</span><br><span class="line">分析：</span><br><span class="line">关键在于在Redis查不到<span class="type">key</span>值，这和缓存击穿有根本的区别，区别在于缓存穿透的情况是传进来的<span class="type">key</span>在Redis中是不存在的。假如有黑客传进大量的不存在的<span class="type">key</span>，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的<span class="type">key</span>就直接返回错误提示，要对调用方保持这种“不信任”的心态。、</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、把无效的Key存进Redis中。如果Redis查不到数据，数据库也查不到，我们把这个Key值保存进Redis，设置value=<span class="string">&quot;null&quot;</span>，当下次再通过这个Key查询时就不需要再查询数据库。这种处理方式肯定是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</span><br><span class="line"><span class="number">2</span>、使用布隆过滤器。布隆过滤器的作用是某个 <span class="type">key</span> 不存在，那么就一定不存在，它说某个 <span class="type">key</span> 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 <span class="type">key</span> 是否存在，如果不存在就直接返回。</span><br><span class="line"></span><br><span class="line">什么是缓存击穿？</span><br><span class="line">缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。</span><br><span class="line">分析：关键在于某个热点的<span class="type">key</span>失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点<span class="type">key</span>不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、上面说过了，如果业务允许的话，对于热点的<span class="type">key</span>可以设置永不过期的<span class="type">key</span>。</span><br><span class="line"><span class="number">2</span>、使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。</span><br><span class="line"></span><br><span class="line">什么是缓存雪崩？</span><br><span class="line">当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</span><br><span class="line">分析：造成缓存雪崩的关键在于在同一时间大规模的<span class="type">key</span>失效。为什么会出现这个问题呢，有几种可能，第一种可能是Redis宕机，第二种可能是采用了相同的过期时间。搞清楚原因之后，那么有什么解决方案呢？</span><br><span class="line">解决方案：</span><br><span class="line"><span class="number">1</span>、在原有的失效时间上加上一个随机值，比如<span class="number">1</span><span class="number">-5</span>分钟随机。这样就避免了因为采用相同的过期时间导致的缓存雪崩。</span><br><span class="line">如果真的发生了缓存雪崩，有没有什么兜底的措施？</span><br><span class="line"><span class="number">2</span>、使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</span><br><span class="line"><span class="number">3</span>、提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</span><br><span class="line"><span class="number">4</span>、为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2023/03/15/9.RabbitMQ/"/>
      <url>/2023/03/15/9.RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程间或同一进程中不同线程间通信的方式</span><br><span class="line">优点：应用耦合、异步处理、流量削锋</span><br><span class="line"></span><br><span class="line">AMQP：一个提供统一消息服务的应用层标准高级消息队列协议</span><br><span class="line">AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</span><br><span class="line"></span><br><span class="line">微服务间通讯有同步和异步两种方式：</span><br><span class="line">同步通讯：就像打电话，需要实时响应</span><br><span class="line">异步通讯：就像发邮件，不需要马上回复</span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>增加权限</span><br><span class="line">1.用户</span><br><span class="line">2.虚拟主机</span><br></pre></td></tr></table></figure><h2 id="同步通讯"><a href="#同步通讯" class="headerlink" title="同步通讯"></a>同步通讯</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Feign调用就属于同步方式，虽然调用可以实时得到结果</span><br></pre></td></tr></table></figure><h2 id="异步通讯"><a href="#异步通讯" class="headerlink" title="异步通讯"></a>异步通讯</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到Broker，不关心谁来订阅事件。订阅者从Broker订阅事件，不关心谁发来的消息。</span><br></pre></td></tr></table></figure><h2 id="简单队列模式的模型图"><a href="#简单队列模式的模型图" class="headerlink" title="简单队列模式的模型图"></a>简单队列模式的模型图</h2><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230216135751240.png" alt="image-20230216135751240" style="zoom:80%;" /><h2 id="RabbitMQ的使用场景"><a href="#RabbitMQ的使用场景" class="headerlink" title="RabbitMQ的使用场景"></a>RabbitMQ的使用场景</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.异步处理</span><br><span class="line"></span><br><span class="line">2.应用解耦</span><br><span class="line"></span><br><span class="line">3.流量削峰</span><br></pre></td></tr></table></figure><h2 id="六种队列"><a href="#六种队列" class="headerlink" title="六种队列"></a>六种队列</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">simple</span>简单模式</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230315162020723.png" alt="image-20230315162020723" style="zoom:80%;" /><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>work工作模式<span class="comment">(资源的竞争)</span></span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230315162055889.png" alt="image-20230315162055889" style="zoom:80%;" /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.publish/subscribe发布订阅(共享资源)</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230315162121898.png" alt="image-20230315162121898" style="zoom:80%;" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.routing路由模式</span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230315162215436.png" alt="image-20230315162215436" style="zoom:80%;" /><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.</span>topic 主题模式<span class="comment">(路由模式的一种)</span></span><br></pre></td></tr></table></figure><img src="C:\Users\ME\AppData\Roaming\Typora\typora-user-images\image-20230315162239577.png" alt="image-20230315162239577" style="zoom:80%;" /><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li>消费者是否消费消息？<br>1.autoAck</li><li>生产者是否发送消息到队列中？<br>1.通过AMQP事务机制实现，AMQP协议层面提供的解决方案  【事务方式、强制同步】<br>2.通过将channel设置成confirm模式来实现  【异步实现】</li></ul><h2 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h2><p>txSelect(),txCommit()以及txRollback()</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>好的，以下是一个基于 Spring AMQP 的增删改查操作的示例代码。这个示例使用 RabbitMQ 作为 AMQP 协议的消息中间件，同时使用 Spring AMQP 实现消息的生产和消费。</p><p>首先，您需要在 pom.xml 中添加 Spring AMQP 和 RabbitMQ 的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，您需要在 Spring Boot 应用程序中配置 RabbitMQ 的连接和交换机：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.host&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.port&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> int port;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.username&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.password&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.virtual-host&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> String virtualHost;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(<span class="string">&quot;<span class="subst">$&#123;spring.rabbitmq.exchange.name&#125;</span>&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> String exchangeName;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> ConnectionFactory connectionFactory() &#123;</span><br><span class="line">    CachingConnectionFactory connectionFactory = new CachingConnectionFactory();</span><br><span class="line">    connectionFactory.setHost(host);</span><br><span class="line">    connectionFactory.setPort(port);</span><br><span class="line">    connectionFactory.setUsername(username);</span><br><span class="line">    connectionFactory.setPassword(password);</span><br><span class="line">    connectionFactory.setVirtualHost(virtualHost);</span><br><span class="line">    <span class="keyword">return</span> connectionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> DirectExchange exchange() &#123;</span><br><span class="line">    <span class="keyword">return</span> new DirectExchange(exchangeName, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个配置类中，我们定义了一个 ConnectionFactory 和一个 DirectExchange，其中 ConnectionFactory 包含了 RabbitMQ 的连接信息，而 DirectExchange 则用来定义交换机的名称。</p><p>接下来，我们需要定义消息的模型和消息的生产者和消费者。假设我们要操作的实体为 User，那么消息模型可以定义如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMessage</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Serializable</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> operation;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个消息模型包含了操作类型和用户实体对象。接下来，我们需要定义消息的生产者和消费者：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMessageProducer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">RabbitTemplate</span> rabbitTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">DirectExchange</span> exchange;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">send</span>(<span class="params">UserMessage userMessage</span>) &#123;</span><br><span class="line">    rabbitTemplate.<span class="title function_">convertAndSend</span>(exchange.<span class="title function_">getName</span>(), <span class="string">&quot;user&quot;</span>, userMessage);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMessageConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">UserService</span> userService;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RabbitListener</span>(queues = <span class="string">&quot;user&quot;</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">receive</span>(<span class="params">UserMessage userMessage</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;create&quot;</span>.<span class="title function_">equals</span>(userMessage.<span class="title function_">getOperation</span>())) &#123;</span><br><span class="line">      userService.<span class="title function_">create</span>(userMessage.<span class="title function_">getUser</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;update&quot;</span>.<span class="title function_">equals</span>(userMessage.<span class="title function_">getOperation</span>())) &#123;</span><br><span class="line">      userService.<span class="title function_">update</span>(userMessage.<span class="title function_">getUser</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;delete&quot;</span>.<span class="title function_">equals</span>(userMessage.<span class="title function_">getOperation</span>())) &#123;</span><br><span class="line">      userService.<span class="title function_">delete</span>(userMessage.<span class="title function_">getUser</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 UserMessageProducer 和一个 UserMessageConsumer，分别用来生产和消费 UserMessage 消息。在生产者中，我们使用 RabbitTemplate 将消息发送到交换机中，而在消费者中，我们根据消息的操作类型调用 UserService 中相应的方法来完成增删改操作。</p><p>最后，我们需要定义 UserService 中的增删改查方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title class_">UserRepository</span> userRepository;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">create</span>(<span class="params">User user</span>) &#123;</span><br><span class="line">    userRepository.<span class="title function_">save</span>(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">update</span>(<span class="params">User user</span>) &#123;</span><br><span class="line">    userRepository.<span class="title function_">save</span>(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">delete</span>(<span class="params">User user</span>) &#123;</span><br><span class="line">    userRepository.<span class="title function_">delete</span>(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">User</span> <span class="title function_">findById</span>(<span class="params">Long id</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.<span class="title function_">findById</span>(id).<span class="title function_">orElse</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title class_">List</span>&lt;<span class="title class_">User</span>&gt; <span class="title function_">findAll</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> userRepository.<span class="title function_">findAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，UserService 中包含了增删改查的方法，具体实现可以根据您的需求进行修改。</p><p>希望这个示例代码能够帮助您实现 Spring AMQP 的增删改查操作！</p>]]></content>
      
      
      <categories>
          
          <category> RabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatisPlus</title>
      <link href="/2023/03/14/8.MyBatisPlus/"/>
      <url>/2023/03/14/8.MyBatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatisPlus"><a href="#MyBatisPlus" class="headerlink" title="MyBatisPlus"></a>MyBatisPlus</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapper层继承<span class="keyword">BaseMapper</span></span><br><span class="line"><span class="keyword"></span>service层继承IService</span><br></pre></td></tr></table></figure><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Wrapper</span>  条件构造抽象类</span><br><span class="line">  <span class="comment">-- AbstractWrapper 查询条件封装，用于生成 sql 中的 where 语句。</span></span><br><span class="line">      <span class="comment">-- QueryWrapper Entity 对象封装操作类，用于查询。</span></span><br><span class="line">      <span class="comment">-- UpdateWrapper Update 条件封装操作类，用于更新。</span></span><br><span class="line">  <span class="comment">-- AbstractLambdaWrapper 使用 Lambda 表达式封装 wrapper</span></span><br><span class="line">      <span class="comment">-- LambdaQueryWrapper 使用 Lambda 语法封装条件，用于查询。</span></span><br><span class="line">      <span class="comment">-- LambdaUpdateWrapper 使用 Lambda 语法封装条件，用于更新。</span></span><br></pre></td></tr></table></figure><h2 id="常用条件"><a href="#常用条件" class="headerlink" title="常用条件"></a>常用条件</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">【通用条件：】</span><br><span class="line">【比较大小： ( =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;= )】</span><br><span class="line">    e<span class="string">q(R column, Object val)</span>; <span class="regexp">//</span> 等价于 =，例: e<span class="string">q(&quot;name&quot;, &quot;老王&quot;)</span> ---&gt; name = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    <span class="keyword">ne</span>(R column, Object val); <span class="regexp">//</span> 等价于 &lt;&gt;，例: <span class="keyword">ne</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>) ---&gt; name &lt;&gt; <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    <span class="keyword">gt</span>(R column, Object val); <span class="regexp">//</span> 等价于 &gt;，例: <span class="keyword">gt</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>) ---&gt; name &gt; <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    ge(R column, Object val); <span class="regexp">//</span> 等价于 &gt;=，例: ge(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>) ---&gt; name &gt;= <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    <span class="keyword">lt</span>(R column, Object val); <span class="regexp">//</span> 等价于 &lt;，例: <span class="keyword">lt</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>) ---&gt; name &lt; <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    le(R column, Object val); <span class="regexp">//</span> 等价于 &lt;=，例: le(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;老王&quot;</span>) ---&gt; name &lt;= <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">    </span><br><span class="line">【范围：（between、<span class="keyword">not</span> between、in、<span class="keyword">not</span> in）】</span><br><span class="line">   between(R column, Object val1, Object val2); <span class="regexp">//</span> 等价于 between a <span class="keyword">and</span> b, 例： between(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">30</span>) ---&gt; age between <span class="number">18</span> <span class="keyword">and</span> <span class="number">30</span></span><br><span class="line">   notBetween(R column, Object val1, Object val2); <span class="regexp">//</span> 等价于 <span class="keyword">not</span> between a <span class="keyword">and</span> b, 例： notBetween(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>, <span class="number">30</span>) ---&gt; age <span class="keyword">not</span> between <span class="number">18</span> <span class="keyword">and</span> <span class="number">30</span></span><br><span class="line">   in(R column, Object... <span class="keyword">values</span>); <span class="regexp">//</span> 等价于 字段 IN (v<span class="number">0</span>, v1, ...),例: in(<span class="string">&quot;age&quot;</span>,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) ---&gt; age in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">   notIn(R column, Object... <span class="keyword">values</span>); <span class="regexp">//</span> 等价于 字段 NOT IN (v<span class="number">0</span>, v1, ...), 例: notIn(<span class="string">&quot;age&quot;</span>,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;) ---&gt; age <span class="keyword">not</span> in (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">   inSql(R column, Object... <span class="keyword">values</span>); <span class="regexp">//</span> 等价于 字段 IN (sql 语句), 例: inSql(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;select id from table where id &lt; 3&quot;</span>) ---&gt; id in (<span class="keyword">select</span> id from table where id &lt; <span class="number">3</span>)</span><br><span class="line">   notInSql(R column, Object... <span class="keyword">values</span>); <span class="regexp">//</span> 等价于 字段 NOT IN (sql 语句)</span><br><span class="line">   </span><br><span class="line">【模糊匹配：（like）】</span><br><span class="line">    like(R column, Object val); <span class="regexp">//</span> 等价于 LIKE <span class="string">&#x27;%值%&#x27;</span>，例: like(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>) ---&gt; name like <span class="string">&#x27;%王%&#x27;</span></span><br><span class="line">    notLike(R column, Object val); <span class="regexp">//</span> 等价于 NOT LIKE <span class="string">&#x27;%值%&#x27;</span>，例: notLike(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>) ---&gt; name <span class="keyword">not</span> like <span class="string">&#x27;%王%&#x27;</span></span><br><span class="line">    likeLeft(R column, Object val); <span class="regexp">//</span> 等价于 LIKE <span class="string">&#x27;%值&#x27;</span>，例: likeLeft(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>) ---&gt; name like <span class="string">&#x27;%王&#x27;</span></span><br><span class="line">    likeRight(R column, Object val); <span class="regexp">//</span> 等价于 LIKE <span class="string">&#x27;值%&#x27;</span>，例: likeRight(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;王&quot;</span>) ---&gt; name like <span class="string">&#x27;王%&#x27;</span></span><br><span class="line">    </span><br><span class="line">【空值比较：（isNull、isNotNull）】</span><br><span class="line">    isNull(R column); <span class="regexp">//</span> 等价于 IS NULL，例: isNull(<span class="string">&quot;name&quot;</span>) ---&gt; name is null</span><br><span class="line">    isNotNull(R column); <span class="regexp">//</span> 等价于 IS NOT NULL，例: isNotNull(<span class="string">&quot;name&quot;</span>) ---&gt; name is <span class="keyword">not</span> null</span><br><span class="line"></span><br><span class="line">【分组、排序：（group、having、order）】</span><br><span class="line">    groupBy(R... columns); <span class="regexp">//</span> 等价于 GROUP BY 字段, ...， 例: groupBy(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>) ---&gt; group by id,name</span><br><span class="line">    orderByAsc(R... columns); <span class="regexp">//</span> 等价于 ORDER BY 字段, ... ASC， 例: orderByAsc(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>) ---&gt; order by id ASC,name ASC</span><br><span class="line">    orderByDesc(R... columns); <span class="regexp">//</span> 等价于 ORDER BY 字段, ... DESC， 例: orderByDesc(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>) ---&gt; order by id DESC,name DESC</span><br><span class="line">    having(String sqlHaving, Object... params); <span class="regexp">//</span> 等价于 HAVING ( sql语句 )， 例: having(<span class="string">&quot;sum(age) &gt; &#123;0&#125;&quot;</span>, <span class="number">11</span>) ---&gt; having sum(age) &gt; <span class="number">11</span></span><br><span class="line"></span><br><span class="line">【拼接、嵌套 sql：（<span class="keyword">or</span>、<span class="keyword">and</span>、nested、apply）】</span><br><span class="line">   <span class="keyword">or</span>(); <span class="regexp">//</span> 等价于 a <span class="keyword">or</span> b， 例：e<span class="string">q(&quot;id&quot;,1)</span>.or().e<span class="string">q(&quot;name&quot;,&quot;老王&quot;)</span> ---&gt; id = <span class="number">1</span> <span class="keyword">or</span> name = <span class="string">&#x27;老王&#x27;</span></span><br><span class="line">   <span class="keyword">or</span>(Consumer&lt;Param&gt; consumer); <span class="regexp">//</span> 等价于 <span class="keyword">or</span>(a <span class="keyword">or</span>/<span class="keyword">and</span> b)，<span class="keyword">or</span> 嵌套。例: <span class="keyword">or</span>(i -&gt; i.e<span class="string">q(&quot;name&quot;, &quot;李白&quot;)</span>.ne(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;活着&quot;</span>)) ---&gt; <span class="keyword">or</span> (name = <span class="string">&#x27;李白&#x27;</span> <span class="keyword">and</span> status &lt;&gt; <span class="string">&#x27;活着&#x27;</span>)</span><br><span class="line">   <span class="keyword">and</span>(Consumer&lt;Param&gt; consumer); <span class="regexp">//</span> 等价于 <span class="keyword">and</span>(a <span class="keyword">or</span>/<span class="keyword">and</span> b)，<span class="keyword">and</span> 嵌套。例: <span class="keyword">and</span>(i -&gt; i.e<span class="string">q(&quot;name&quot;, &quot;李白&quot;)</span>.ne(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;活着&quot;</span>)) ---&gt; <span class="keyword">and</span> (name = <span class="string">&#x27;李白&#x27;</span> <span class="keyword">and</span> status &lt;&gt; <span class="string">&#x27;活着&#x27;</span>)</span><br><span class="line">   nested(Consumer&lt;Param&gt; consumer); <span class="regexp">//</span> 等价于 (a <span class="keyword">or</span>/<span class="keyword">and</span> b)，普通嵌套。例: nested(i -&gt; i.e<span class="string">q(&quot;name&quot;, &quot;李白&quot;)</span>.ne(<span class="string">&quot;status&quot;</span>, <span class="string">&quot;活着&quot;</span>)) ---&gt; (name = <span class="string">&#x27;李白&#x27;</span> <span class="keyword">and</span> status &lt;&gt; <span class="string">&#x27;活着&#x27;</span>)</span><br><span class="line">   apply(String applySql, Object... params); <span class="regexp">//</span> 拼接sql（若不使用 params 参数，可能存在 sql 注入），例: apply(<span class="string">&quot;date_format(dateColumn,&#x27;%Y-%m-%d&#x27;) = &#123;0&#125;&quot;</span>, <span class="string">&quot;2008-08-08&quot;</span>) ---&gt; date_format(dateColumn,<span class="string">&#x27;%Y-%m-%d&#x27;</span>) = <span class="string">&#x27;2008-08-08&#x27;</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">   last(String lastSql); // 无视优化规则直接拼接到 sql 的最后，可能存若在 sql 注入。</span></span><br><span class="line"><span class="string">   exists(String existsSql); // 拼接 exists 语句。例: exists(&quot;</span><span class="keyword">select</span> id from table where age = <span class="number">1</span><span class="string">&quot;) ---&gt; exists (select id from table where age = 1)</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">【QueryWrapper 条件：】</span></span><br><span class="line"><span class="string">    select(String... sqlSelect); // 用于定义需要返回的字段。例： select(&quot;</span>id<span class="string">&quot;, &quot;</span>name<span class="string">&quot;, &quot;</span>age<span class="string">&quot;) ---&gt; select id, name, age</span></span><br><span class="line"><span class="string">    select(Predicate&lt;TableFieldInfo&gt; predicate); // Lambda 表达式，过滤需要的字段。</span></span><br><span class="line"><span class="string">    lambda(); // 返回一个 LambdaQueryWrapper</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">【UpdateWrapper 条件：】</span></span><br><span class="line"><span class="string">    set(String column, Object val); // 用于设置 set 字段值。例: set(&quot;</span>name<span class="string">&quot;, null) ---&gt; set name = null</span></span><br><span class="line"><span class="string">    etSql(String sql); // 用于设置 set 字段值。例: setSql(&quot;</span>name = <span class="string">&#x27;老李头&#x27;</span><span class="string">&quot;) ---&gt; set name = &#x27;老李头&#x27;</span></span><br><span class="line"><span class="string">    lambda(); // 返回一个 LambdaUpdateWrapper```</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MyBatisPlus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/03/14/7.MyBatis/"/>
      <url>/2023/03/14/7.MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p>Mybatis是一款优秀的持久层框架。<br>它支持定制化SQL、存储过程以及高级映射。<br>Mybatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。<br>Mybatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO(Plain Old Java Object，普通老式Java对象)为数据库中的记录。<br>Mybatis本是Apache的一个开源项目Ibatis，2010年这个项目由Apache software foundation迁移到了Google Code，并改名为Mybatis。<br>2013年11月迁移到Github。</p><h1 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h1>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC</title>
      <link href="/2023/03/14/6.SpringMVC/"/>
      <url>/2023/03/14/6.SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC基本说明"><a href="#SpringMVC基本说明" class="headerlink" title="SpringMVC基本说明"></a>SpringMVC基本说明</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC是基于Spring的，是Spring中的一个模块，专门用来做web开发使用的。 </span><br><span class="line"></span><br><span class="line">SpringMVC 也叫 Spring web mvc。是 Spring 框架的一部分，是在Spring3.0 后发布的。基于 MVC 架构，功能分工明确、解耦合。</span><br><span class="line"></span><br><span class="line">SpringMVC也是一个容器，使用IoC核心技术，管理界面层中的控制器对象。SpringMVC的底层就是servlet，以servlet为核心，接收请求、处理请求，显示处理结果给用户。在此之前这个功能是由Servlet来实现的，现在使用SpringMVC来代替Servlet行驶控制器的角色和功能。</span><br><span class="line"></span><br><span class="line">其核心Servlet是：DispatcherServlet</span><br></pre></td></tr></table></figure><h1 id="SpringMVC框架的优点"><a href="#SpringMVC框架的优点" class="headerlink" title="SpringMVC框架的优点"></a>SpringMVC框架的优点</h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 基于 MVC 架构，功能分工明确。解耦合。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>容易理解，上手快；使用简单。就可以开发一个注解的 SpringMVC 项目，SpringMVC 也是轻量级的，jar 很小。不依赖的特定的接口和类。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>作为 Spring 框架一部分，能够使用 Spring 的 IoC 和 Aop。方便整合Strtus，MyBatis，Hiberate, JPA 等其他框架。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>SpringMVC 强化注解的使用，在控制器，Service，Dao 都可以使用注解。方便灵活。使用<span class="meta">@Controller</span> 创建处理器对象,<span class="meta">@Service</span> 创建业务对象，<span class="meta">@Autowired</span> 或者<span class="meta">@Resource</span> 在控制器类中注入 Service, Service 类中注入Dao。</span><br></pre></td></tr></table></figure><h2 id="使用SpringMVC框架处理MVC请求的顺序"><a href="#使用SpringMVC框架处理MVC请求的顺序" class="headerlink" title="使用SpringMVC框架处理MVC请求的顺序"></a>使用SpringMVC框架处理MVC请求的顺序</h2><p><img src="https://img-blog.csdnimg.cn/20210811223951381.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhhaXlhbmc5OA==,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h2><p><img src="https://img-blog.csdnimg.cn/20210812215624937.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWhhaXlhbmc5OA==,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/03/12/5.Spring/"/>
      <url>/2023/03/12/5.Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Spring框架的核心就是IoC（控制反转）和AOP（面向切面编程）。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>面向切面编程（AOP）是软件编程思想发展到一定程度的产物，是对面向对象编程的有益补充。AOP一般适用于具有横切逻辑的场合，如事务管理、访问控制、性能监控等。<br>面向切面编程，简单地说就是在不改变源程序的基础上为代码段增加新的功能，对代码段进行增强处理。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>实例化（Spring容器使用Java反射机制根据Bean的定义（通常是通过配置文件或注解进行定义）创建Bean的实例。具体实例化的方式可以是通过构造函数实例化或通过工厂方法等方式）<br>属性赋值（Spring容器将通过依赖注入（Dependency Injection）机制，根据配置或注解将Bean所需的属性值（依赖）设置到Bean实例中）<br>初始化前回调<br>初始化后回调<br>使用<br>销毁</p><h1 id="SpringbbotApplicat-springmvc-注解分析"><a href="#SpringbbotApplicat-springmvc-注解分析" class="headerlink" title="SpringbbotApplicat springmvc 注解分析"></a>SpringbbotApplicat springmvc 注解分析</h1><h2 id="SpringbbotApplicat注解分析"><a href="#SpringbbotApplicat注解分析" class="headerlink" title="SpringbbotApplicat注解分析"></a>SpringbbotApplicat注解分析</h2><p>1.@ComponentScan<br>告诉Spring那个package的用注解标识的类会被Spring自动扫描并切装入IoC容器中。<br>自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义<br>2.@SpringBootConfiguration<br>继承自@Configuration，二者功能基本一致，标注当前类是配置类，除此之外，会在当前类内声明一个或多个以@Bean注解标记的方法实例纳入到Spring容器中。并且实例方法就是方法名。<br>3.@EnableAutoConfiguration<br>借助@Import的支持，收集和注册特定场景相关的Bean配置。将所有符合自动配置条件的bean定义加载到IoC容器。</p><p>@SpringBootApplication是Spring Boot应用程序的核心注解之一。它是一个组合注解，结合了以下三个注解的功能：<br>@Configuration：将类标记为应用程序上下文的配置类，告诉Spring容器该类包含Bean的定义。<br>@EnableAutoConfiguration：启用自动配置功能，使Spring Boot根据项目的依赖配置自动配置应用程序。<br>@ComponentScan：自动扫描并注册注解类的Bean，使得Spring能够发现和管理这些注解类的实例。</p><p>通过在主类上使用@SpringBootApplication注解，可以减少开发者的配置工作，自动配置Spring Boot应用程序的行为和特性，简化了项目的启动和部署过程。<br>以下是每个注解的功能和作用：<br>@Configuration：标记一个类为Spring的配置类，类中的@Bean注解的方法用于定义和配置Bean。<br>@EnableAutoConfiguration：开启Spring Boot的自动配置功能。它根据项目的依赖和配置，自动配置和装配应用程序所需的Bean和组件。<br>@ComponentScan：自动扫描被@Component、@Controller、@Service以及@Repository等注解标记的类，并将其注册为Spring的Bean，使其能够被自动装配和使用。<br>总而言之，@SpringBootApplication注解是一个集成了配置、自动装配和组件扫描功能的核心注解，方便开发者使用Spring Boot快速构建和部署应用程序。</p><h2 id="mvc形参注解"><a href="#mvc形参注解" class="headerlink" title="mvc形参注解"></a>mvc形参注解</h2><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p>Controller注解用于指示Spring类的实例是一个控制器<br>通过HttpServletRequst接收请求参数request.getParameter(“age”)</p><p>1.RequestParam注解作用：把请求中的指定名称的参数传递给控制器中的形参赋值<br>@RequestParam(value&#x3D;”name”,required&#x3D;false)String username</p><p>2.通过PathVariable注解接收请求参数<br>PathVariable注解作用：拥有绑定url中的占位符的。例如：url中有&#x2F;delete&#x2F;{id}，{id}就是占位符<br>注解属性 value：指定url中的占位符名称<br>@PathVariable(value&#x3D;”id”) String id</p><p>3.@RequestBody 接收前端传递给后端的json字符串中的数据的(请求体中的数据的)<br>RequestBody与@RequestParam()可以同时使用，@RequestBody最多只有一个，而@RequestParam()可以有多个。<br>RequestBody 接收的是请求体里面的数据；而RequestParam接收的是key-value</p><p>@RequestBody直接以String接收前端传过来的json数据<br>@RequestBody以简单对象接收前端传过来的json数据<br>@RequestBody接收请求体中的json数据；不加注解接收URL中的数据并组装为对象：</p><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>作用：将方法的返回值，以特定的格式写入到response的body区域，进而将数据返回给客户端。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/03/12/4.Linux/"/>
      <url>/2023/03/12/4.Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Linux常见命令"><a href="#1-Linux常见命令" class="headerlink" title="1.Linux常见命令"></a>1.Linux常见命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. ls：显示目录或文件的列表</span><br><span class="line">2. cd：切换目录</span><br><span class="line">3. pwd：显示当前工作目录的绝对路径</span><br><span class="line">4. mkdir：创建新目录</span><br><span class="line">5. rmdir：删除空目录</span><br><span class="line">6. touch：创建新文件或修改文件时间戳</span><br><span class="line">7. cp：复制文件或目录</span><br><span class="line">8. mv：移动或重命名文件或目录</span><br><span class="line">9. rm：删除文件或目录</span><br><span class="line">10. cat：查看文件内容</span><br><span class="line">11. chmod：修改文件或目录的权限</span><br><span class="line">12. chown：修改文件或目录的所有者</span><br><span class="line">13. chgrp：修改文件或目录的所属组</span><br><span class="line">14. ps：查看进程信息</span><br><span class="line">15. top：实时查看系统资源使用情况</span><br><span class="line">16. du：查看文件或目录占用磁盘空间的大小</span><br><span class="line">17. df：查看磁盘空间使用情况</span><br><span class="line">18. echo：输出文本内容</span><br><span class="line">19. grep：在文件中查找指定字符串</span><br><span class="line">20. tar：打包或解包文件</span><br><span class="line">21. unzip：解压缩zip压缩文件</span><br><span class="line">22. curl：从服务器获取数据</span><br><span class="line">23. wget：从Web服务器下载文件</span><br><span class="line">24. ping：测试网络连接</span><br><span class="line">25. ifconfig/ip：显示网络接口的配置信息</span><br><span class="line">26. ssh：建立安全的远程连接</span><br><span class="line">27. scp：将文件从本地复制到远程主机上</span><br><span class="line">28. crontab：定时任务管理工具</span><br><span class="line">29. systemctl/service：查看和管理系统服务</span><br><span class="line">30. history：查看命令历史记录。</span><br><span class="line">31. </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL日常优化</title>
      <link href="/2023/03/12/3.SQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/03/12/3.SQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-获取系统当前时间"><a href="#1-获取系统当前时间" class="headerlink" title="1.获取系统当前时间"></a>1.获取系统当前时间</h1><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">MySQL:</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line">NOW()函数返回当前日期和时间，格式为<span class="string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span>。</span><br><span class="line"></span><br><span class="line"><span class="symbol">Oracle:</span></span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><h1 id="2-分页"><a href="#2-分页" class="headerlink" title="2.分页"></a>2.分页</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MySQL:</span><br><span class="line">Limit</span><br><span class="line"></span><br><span class="line">Oracle:</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> t.<span class="operator">*</span>, ROWNUM rn</span><br><span class="line">  <span class="keyword">FROM</span> table_name t</span><br><span class="line">  <span class="keyword">WHERE</span> ...</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> rn <span class="keyword">BETWEEN</span> start_row <span class="keyword">AND</span> end_row;</span><br></pre></td></tr></table></figure><h1 id="3-空值转换函数"><a href="#3-空值转换函数" class="headerlink" title="3.空值转换函数"></a>3.空值转换函数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NVL函数是一个ORACLE空值转换函数</span><br><span class="line">IFNULL函数是一个MYSQL空值转换函数</span><br><span class="line"></span><br><span class="line">其表达式的值可以是数字型、字符型和日期型。但是表达式1和表达式2的数据类型必须为同一个类型。</span><br><span class="line">对数字型： NVL（ <span class="built_in">comm</span>,0);</span><br><span class="line">对字符型 NVL( TO_CHAR(<span class="built_in">comm</span>), <span class="string">&#x27;No Commission&#x27;</span>)</span><br><span class="line">对日期型 NVL（hiredate,<span class="string">&#x27; 31-DEC-99&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="4-SQL的索引"><a href="#4-SQL的索引" class="headerlink" title="4.SQL的索引"></a>4.SQL的索引</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">索引是关系型数据库中的重要组件，它可以提高数据库的查询性能。通过索引，可以快速高效地定位到需要查询的数据，减少数据库的IO操作，从而提高数据库的查询速度和性能。</span><br><span class="line"></span><br><span class="line">SQL中的索引可以分为以下几种类型：</span><br><span class="line"><span class="bullet">1.</span> 唯一索引：保证索引列的所有值都是唯一的，即不允许重复值。</span><br><span class="line"><span class="bullet">2.</span> 主键索引：特殊的唯一索引，用于保证表中每行数据的唯一性。</span><br><span class="line"><span class="bullet">3.</span> 外键索引：用于实现表与表之间的关联，保证引用了外键的字段值必须是被引用表的主键值。</span><br><span class="line"><span class="bullet">4.</span> 聚簇索引：物理存储上按照索引列排序并存储数据，可以提高查询效率。</span><br><span class="line"><span class="bullet">5.</span> 非聚簇索引：物理存储上不按照索引列排序存储数据，查询时需要通过指针查找数据，速度相对较慢。</span><br><span class="line"><span class="bullet">6.</span> 全文索引：用于对文本内容进行高效的查询，支持模糊查询和关键字搜索等。</span><br><span class="line"><span class="bullet">7.</span> 组合索引：一种同时包含多个列的索引，可以提高复合条件查询的效率。</span><br><span class="line"></span><br><span class="line">总之，选择合适的索引类型，并且正确地创建和使用索引，可以大大提高数据库的性能和查询效率。</span><br></pre></td></tr></table></figure><h1 id="5-SQL事务"><a href="#5-SQL事务" class="headerlink" title="5.SQL事务"></a>5.SQL事务</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ACID</span></span><br><span class="line">原子性：一个事务中的所有 SQL 语句，要么全部执行成功，要么全部执行失败</span><br><span class="line">一致性：一致性确保事务将数据库从一个一致的状态转换为另一个一致的状态。在每个事务开始之前和结束之后，数据库的完整性约束保持一致。</span><br><span class="line">隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致</span><br><span class="line">持久性：持久性确保已提交的事务对数据库的更改是永久的，即使在系统故障或崩溃时也是如此。一旦事务提交，其所做的更改将被永久保存在数据库中，并且不能被回滚。</span><br></pre></td></tr></table></figure><h1 id="6-事务隔离级别"><a href="#6-事务隔离级别" class="headerlink" title="6.事务隔离级别"></a>6.事务隔离级别</h1><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">事务隔离分为不同级别，包括</span><br><span class="line">读未提交（<span class="keyword">Read</span> <span class="keyword">uncommitted</span>）、（出现脏读）</span><br><span class="line">读已提交（<span class="keyword">read</span> <span class="keyword">committed</span>）、（）</span><br><span class="line">可重复读（<span class="keyword">repeatable</span> <span class="keyword">read</span>）、（）</span><br><span class="line">串行化（<span class="keyword">Serializable</span>）、（）</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>读未提交（<span class="keyword">Read</span> <span class="keyword">Uncommitted</span>）：</span><br><span class="line">读未提交是最低的隔离级别，它允许一个事务读取另一个未提交的事务所做的变更。在该隔离级别下，可能会出现脏读问题（读取到未提交的数据）。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>读已提交（<span class="keyword">Read</span> <span class="keyword">Committed</span>）：</span><br><span class="line">读已提交要求一个事务只能读取并访问已经提交的数据。在该隔离级别下，事务的读操作可以避免脏读问题，但可能出现不可重复读问题（多次读取同一记录的结果不一致）。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>可重复读（<span class="keyword">Repeatable</span> <span class="keyword">Read</span>）：</span><br><span class="line">可重复读要求一个事务在执行期间多次读取同一记录时，结果保持一致。在该隔离级别下，事务读取的数据是事务开始时的一个快照，并且其他并发事务的写操作不会影响到该事务。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>串行化（<span class="keyword">Serializable</span>）：</span><br><span class="line">串行化是最高的隔离级别，它要求事务按照顺序一个接一个地执行，即事务之间是完全隔离的。在该隔离级别下，可以避免脏读、不可重复读和幻读问题（读取到其他事务插入的新数据）。</span><br><span class="line">不同的隔离级别在数据一致性和并发性之间存在一定的权衡。隔离级别越高，数据的一致性越好，但并发性越低，可能导致性能下降。因此，选择适当的隔离级别需要根据应用场景和需求来进行权衡。</span><br><span class="line"></span><br><span class="line">在实际应用中，默认的隔离级别通常是读已提交（<span class="keyword">Read</span> <span class="keyword">Committed</span>），因为它能够提供较好的数据一致性和并发性的平衡。如果应用对并发性要求不高，或者对数据一致性要求非常高，可以选择更高的隔离级别。</span><br></pre></td></tr></table></figure><p>MySQL 默认隔离级别是可重复读（Repeatable Read）。</p><p>在可重复读隔离级别下，MySQL事务会创建一个一致性视图，保证事务中的查询操作都是基于事务开始时的数据快照进行的，即使其他事务对数据进行了修改，当前事务也不会看到这些修改。这就避免了脏读和不可重复读问题。<br>注意，MySQL的可重复读隔离级别依赖于多版本并发控制（MVCC）机制。<br>Oracle 默认隔离级别是读已提交（Read Committed）。</p><p>在读已提交隔离级别下，Oracle事务只能读取并访问已经提交的数据。每个读操作都会读取最新的提交数据，避免了脏读问题，但仍然可能出现不可重复读和幻读问题。<br>Oracle也支持更高的隔离级别，如可重复读和序列化，但需要显式设置。<br>需要注意的是，MySQL和Oracle都允许用户根据需要显式地设置事务的隔离级别，以满足特定的业务需求和数据一致性要求。</p><h1 id="7-SQL约束"><a href="#7-SQL约束" class="headerlink" title="7.SQL约束"></a>7.SQL约束</h1><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">NOT</span> <span class="keyword">NULL</span> - 指示某列不能存储 <span class="keyword">NULL</span> 值。</span><br><span class="line"><span class="keyword">UNIQUE</span> - 保证某列的每行必须有唯一的值。</span><br><span class="line"><span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> - <span class="keyword">NOT</span> <span class="keyword">NULL</span> 和 <span class="keyword">UNIQUE</span> 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> - 保证一个表中的数据匹配另一个表中的值的参照完整性。</span><br><span class="line"><span class="keyword">CHECK</span> - 保证列中的值符合指定的条件。</span><br><span class="line">DEFAULT - 规定没有给列赋值时的默认值</span><br></pre></td></tr></table></figure><h1 id="锁带来的四种并发一致性问题"><a href="#锁带来的四种并发一致性问题" class="headerlink" title="锁带来的四种并发一致性问题"></a>锁带来的四种并发一致性问题</h1><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">丢失更新 <span class="built_in">Last</span> <span class="variable">To</span> <span class="variable">Modify</span></span><br><span class="line">丢失更新非常好理解，简单来说其就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</span><br><span class="line"></span><br><span class="line">脏读 <span class="variable">Dirty</span> <span class="built_in">Read</span></span><br><span class="line">所谓脏读，就是说一个事务读到了另外一个事务中的 <span class="string">&quot;脏数据&quot;</span>，脏数据就是指事务未提交的数据</span><br><span class="line"></span><br><span class="line">不可重复读 <span class="variable">Unrepeatableread</span></span><br><span class="line">不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些修改操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。</span><br><span class="line"></span><br><span class="line">幻读 <span class="variable">Phantom</span> <span class="built_in">Read</span></span><br><span class="line">幻读本质上是属于不可重复读的一种情况，区别在于，不可重复读主要是针对数据的更新（即事务的两次读取结果值不一样），而幻读主要是针对数据的增加或减少（即事务的两次读取结果返回的数量不一样）</span><br><span class="line"></span><br><span class="line">不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了事务一致性的要求。</span><br></pre></td></tr></table></figure><p><a href="https://pic1.zhimg.com/80/v2-930707a1c8ca2c88d6919814c270ce84_1440w.webp">https://pic1.zhimg.com/80/v2-930707a1c8ca2c88d6919814c270ce84_1440w.webp</a></p><p>可以看到四种隔离级别能阻止的并发一致性问题越来越多，但并不代表越高的隔离级别就越好，因为事务隔离级别越高，数据库付出的性能代价也就相应地越大。</p><p>另外，多提一嘴，InnoDB 存储引擎在 REPEATABLE READ 事务隔离级别下，使用 Next-Key Lock 锁的算法避免了幻读的产生。也就是说，InnoDB 存储引擎在其默认的 REPEATABLE READ 事务隔离级别下就已经能完全保证事务的隔离性要求了，即达到了 SQL 标准的 SERIALIZABLE 隔离级别。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化</title>
      <link href="/2023/03/12/2.SQL%E4%BC%98%E5%8C%96/"/>
      <url>/2023/03/12/2.SQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="1-避免使用-select"><a href="#1-避免使用-select" class="headerlink" title="1.避免使用 select *"></a>1.避免使用 select *</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> 不会走覆盖索引，会出现大量的回表操作，而从导致查询 <span class="keyword">sql</span> 的性能很低。</span><br><span class="line">多查出来的数据，通过网络 IO 传输的过程中，也会增加数据传输的时间。</span><br></pre></td></tr></table></figure><h3 id="2-用-union-all-代替-union"><a href="#2-用-union-all-代替-union" class="headerlink" title="2.用 union all 代替 union"></a>2.用 union all 代替 union</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="built_in">union</span> 关键字后，可以获取排重后的数据。</span><br><span class="line">使用 <span class="built_in">union</span> <span class="built_in">all</span> 关键字，可以获取所有数据，包含重复的数据。</span><br><span class="line"></span><br><span class="line">排重的过程需要遍历、排序和比较，它更耗时，更消耗 cpu 资源。</span><br><span class="line">除非，业务场景中是不允许产生重复数据的，这时可以使用 <span class="built_in">union</span>。</span><br></pre></td></tr></table></figure><h3 id="3-小表驱动大表"><a href="#3-小表驱动大表" class="headerlink" title="3.小表驱动大表"></a>3.小表驱动大表</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以使用 in 关键字实现：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">where</span> user_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> status=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">可以使用 <span class="keyword">exists</span> 关键字实现：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">order</span>.user_id = <span class="keyword">user</span>.id <span class="keyword">and</span> status=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> 适用于左边大表，右边小表。</span><br><span class="line"><span class="keyword">exists</span> 适用于左边小表，右边大表。</span><br></pre></td></tr></table></figure><h3 id="4-批量操作"><a href="#4-批量操作" class="headerlink" title="4.批量操作"></a>4.批量操作</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">orderMapper.insert<span class="constructor">Batch(<span class="params">list</span>)</span>:</span><br><span class="line">尽量少请求连接数据库</span><br><span class="line">建议每批数据尽量控制在 <span class="number">500</span> 以内。如果数据多于 <span class="number">500</span>，则分多批次处理</span><br></pre></td></tr></table></figure><h3 id="5-多用-limit"><a href="#5-多用-limit" class="headerlink" title="5.多用 limit"></a>5.多用 limit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="built_in">limit</span> 1，只返回该用户下单时间最小的那一条数据</span><br></pre></td></tr></table></figure><h3 id="6-in-中值太多"><a href="#6-in-中值太多" class="headerlink" title="6.in 中值太多"></a>6.in 中值太多</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Category&gt; <span class="title function_">getCategory</span><span class="params">(List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(CollectionUtils.isEmpty(ids)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(ids.size() &gt; <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;一次最多允许查询500条记录&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mapper.getCategoryList(ids);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">超过 <span class="number">500</span> 条记录，可以分批用多线程去查询数据。每批只查 <span class="number">500</span> 条记录，最后把查询到的数据汇总到一起返回。</span><br><span class="line">    </span><br><span class="line">临时方案，不适合于 ids 实在太多的场景。因为 ids 太多，即使能快速查出数据，但如果返回的数据量太大了，网络传输也是非常消耗性能的，接口性能始终好不到哪里去。</span><br></pre></td></tr></table></figure><h3 id="7-增量查询"><a href="#7-增量查询" class="headerlink" title="7.增量查询"></a>7.增量查询</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按 <span class="built_in">id</span> 和时间升序，每次只同步一批数据，这一批数据只有 <span class="number">100</span> 条记录。每次同步完成之后，保存这 <span class="number">100</span> 条数据中最大的 <span class="built_in">id</span> 和时间，给同步下一批数据的时候用。</span><br><span class="line"></span><br><span class="line">通过这种增量查询的方式，能够提升单次查询的效率。</span><br></pre></td></tr></table></figure><h3 id="8-高效的分页"><a href="#8-高效的分页" class="headerlink" title="8.高效的分页"></a>8.高效的分页</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。</span><br></pre></td></tr></table></figure><h3 id="9-用连接查询代替子查询"><a href="#9-用连接查询代替子查询" class="headerlink" title="9.用连接查询代替子查询"></a>9.用连接查询代替子查询</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mysql</span> 执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。</span><br><span class="line">子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。</span><br><span class="line"></span><br><span class="line">连接查询（内连接）</span><br></pre></td></tr></table></figure><h3 id="10-join-的表不宜过多"><a href="#10-join-的表不宜过多" class="headerlink" title="10.join 的表不宜过多"></a>10.join 的表不宜过多</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据阿里巴巴开发者手册的规定，<span class="keyword">join</span> 表的数量不应该超过 <span class="number">3</span> 个</span><br><span class="line"></span><br><span class="line"><span class="keyword">join</span> 表的数量要根据系统的实际情况决定，不能一概而论，尽量越少越好</span><br></pre></td></tr></table></figure><h3 id="11-join-时要注意"><a href="#11-join-时要注意" class="headerlink" title="11.join 时要注意"></a>11.join 时要注意</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">涉及到多张表联合查询的时候，一般会使用 <span class="keyword">join</span> 关键字</span><br><span class="line"></span><br><span class="line">如果两张表使用 <span class="keyword">inner</span> <span class="keyword">join</span> 关联，mysql 会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题</span><br><span class="line"></span><br><span class="line">如果两张表使用 <span class="keyword">left</span> <span class="keyword">join</span> 关联，mysql 会默认用 <span class="keyword">left</span> <span class="keyword">join</span> 关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。</span><br><span class="line"></span><br><span class="line">要特别注意的是在用 <span class="keyword">left</span> <span class="keyword">join</span> 关联查询时，左边要用小表，右边可以用大表。如果能用 <span class="keyword">inner</span> <span class="keyword">join</span> 的地方，尽量少用 <span class="keyword">left</span> <span class="keyword">join</span>。</span><br></pre></td></tr></table></figure><h3 id="12-控制索引的数量"><a href="#12-控制索引的数量" class="headerlink" title="12.控制索引的数量"></a>12.控制索引的数量</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">索引能够显著的提升查询 <span class="keyword">sql</span> 的性能，但索引数量并非越多越好。</span><br><span class="line">因为表中新增数据时，需要同时为它创建索引，而索引是需要额外的存储空间的，而且还会有一定的性能消耗。</span><br><span class="line"></span><br><span class="line">阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在 <span class="number">5</span> 个以内，并且单个索引中的字段数不超过 <span class="number">5</span> 个。</span><br><span class="line">mysql 使用的 B <span class="operator">+</span> 树的结构来保存索引的，在 <span class="keyword">insert</span>、<span class="keyword">update</span> 和 <span class="keyword">delete</span> 操作时，需要更新 B <span class="operator">+</span> 树索引。如果索引过多，会消耗很多额外的性能。</span><br><span class="line"></span><br><span class="line">但对于一些高并发的系统，请务必遵守单表索引数量不要超过 <span class="number">5</span> 的限制。</span><br><span class="line">能够建联合索引，就别建单个索引，可以删除无用的单个索引。</span><br><span class="line"></span><br><span class="line">将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase 等，在业务表中只需要建几个关键索引即可。</span><br></pre></td></tr></table></figure><h3 id="13-选择合理的字段类型"><a href="#13-选择合理的字段类型" class="headerlink" title="13.选择合理的字段类型"></a>13.选择合理的字段类型</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 表示固定字符串类型，该类型的字段存储空间的固定的，会浪费存储空间。</span><br><span class="line"><span class="type">varchar</span> 表示变长字符串类型，该类型的字段存储空间会根据实际数据的长度调整，不会浪费存储空间。</span><br><span class="line"></span><br><span class="line">能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。</span><br><span class="line">尽可能使用小的类型，比如：用 <span class="type">bit</span> 存布尔值，用 tinyint 存枚举值等。</span><br><span class="line">长度固定的字符串字段，用 <span class="type">char</span> 类型。</span><br><span class="line">长度可变的字符串字段，用 <span class="type">varchar</span> 类型。</span><br><span class="line">金额字段用 <span class="type">decimal</span>，避免精度丢失问题。</span><br></pre></td></tr></table></figure><h3 id="14-提升-group-by-的效率"><a href="#14-提升-group-by-的效率" class="headerlink" title="14.提升 group by 的效率"></a>14.提升 group by 的效率</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 关键字，它主要的功能是去重和分组。</span><br><span class="line">通常它会跟 <span class="keyword">having</span> 一起配合使用，表示分组后再根据一定的条件过滤数据。</span><br><span class="line"></span><br><span class="line"><span class="keyword">sql</span> 语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升 <span class="keyword">sql</span> 整体的性能。</span><br></pre></td></tr></table></figure><h3 id="15-索引优化"><a href="#15-索引优化" class="headerlink" title="15.索引优化"></a>15.索引优化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql 语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为 sql 优化的首选。</span><br><span class="line"></span><br><span class="line">查看 mysql 的执行计划:</span><br><span class="line">explain select * from `order` where code=&#x27;002&#x27;;</span><br></pre></td></tr></table></figure><p>执行计划包含列的含义</p><p><img src="https://pic.imgdb.cn/item/618bcb752ab3f51d910ae306.jpg" alt="img"></p><p>索引失效的常见原因</p><p><img src="https://pic.imgdb.cn/item/618bcb872ab3f51d910ae8ed.jpg" alt="img"></p><h3 id="16-索引优化"><a href="#16-索引优化" class="headerlink" title="16.索引优化"></a>16.索引优化</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MySQL优化器会自动调整a,b的顺序与索引的顺序一致</span><br><span class="line"></span><br><span class="line">(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>最左前缀匹配原则</span><br><span class="line">(<span class="number">1</span>)联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。但是，对于 &gt;=、&lt;=、<span class="keyword">BETWEEN</span>、<span class="keyword">like</span> 前缀匹配这四种范围查询，并不会停止匹配</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line">索引：只有在B+树的数据是有序的情况下，才能通过二分法查找到对应的；如果是无序的，无法通过二分法找到对应的数据，索引就无法使用</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">最左匹配原则都是针对联合索引来说的，所以我们可以从联合索引的原理来了解最左匹配原则。</span><br><span class="line">我们都知道索引的底层是一颗 B+ 树，那么联合索引当然还是一颗 B+ 树，只不过联合索引的健值数量不是一个，而是多个。构建一颗 B+ 树只能根据一个值来构建，因此数据库依据联合索引最左的字段来构建 B+ 树。</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>)</span><br><span class="line">查询的数据类型要正确</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_date &gt;= now();</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> create_date &gt;= <span class="string">&#x27;2020-05-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p>数据库字段选择<br>MySQL与Java常用数据类型的对应关系<br>一、字符串数据类型:<br>MySQL类型名大小用途对应Java类名<br>char0-255 bytes定长字符串 （姓名、性别、学号）String<br>varchar0-65535 bytes变长字符串（比上面更长一点的那种）String<br>tinytext0-255 bytes比较短的那种文本数据（新闻速报的那种）String<br>mediumtext0-16 777 215 bytes中等长度的文本数据（小作文）String<br>text0-65 535 bytes长文本数据（比上面更长一点的那种）String<br>longtext0-4 294 967 295 bytes极大文本数据（论文）String<br>enum 枚举<br>二、日期&#x2F;时间数据类型：<br>这个时间的对应的Java类、只要格式正确、都是可以取的，主要看需求是什么。不管你后端是String、Date 类型、只要格式是对应的就是可以的。<br>MySQL类型名用途<br>dateYYYY-MM-DD格式的日期值<br>timehh:mm:ss格式的时间值<br>datetimeYYYY-MM-DD hh:mm:ss格式的日期和时间值<br>timestampYYYY-MM-DD hh:mm:ss格式的时间戳记值<br>yearYYYY或YY格式的年值<br>三、数值数据类型：<br>MySQL类型名用途　对应Java类名<br>tinyint一个很小很小的整数Integer<br>smallint一个小整数Integer<br>int一个int大小的整数 （大都用来做id）Integer<br>mediumint一个中等大小的整数Integer<br>bigint一个蛮大的整数（也常用来做id）Long<br>float学生成绩、允许有误差的、单精度浮点数Float<br>double学生成绩、允许有误差的、双精度浮点数Double<br>decimal计算工资、盈利、金融方面Java.math.BigDecimal<br>四、二进制数据类型：<br>MySQL类型名描述<br>tityblob不超过 255 个字符的二进制字符串<br>blob二进制形式的长文本数据<br>mediumblob二进制形式的中等长度文本数据<br>longblob二进制形式的极大文本数据</p><p>MySQL 常用字段类型与对应的Java类型<br>1.varchar<br>不定长字符串<br>字符串或是没有合适类型时，可以选择它作为字段类型<br>对应Java中的String</p><p>2.int bigint<br>数值<br>一般以int作为数字的默认选择，数值很大时使用bigint<br>对应Java中的Long</p><p>3.char<br>定长字符串<br>适用于盐、md5加密后的密码等情况<br>对应Java中的String</p><p>4.float double<br>浮点数<br>适用于各种小数，除非金额等情况，小数推荐使用double<br>各自对应Java中的Float，Double</p><p>5.decimal<br>精确浮点数<br>适用于金额<br>对应Java中的BigDecimal</p><p>6.tinyint<br>逻辑型<br>适用于是&#x2F;否的情况，ORM框架一般会将其映射为true&#x2F;false<br>对应Java中的Boolean<br>还有正整数 unsigned</p><p>7.date time datetime<br>“时间”<br>各自适用于年月日，时分秒，年月日时分秒三种情况<br>都对应Java中的java.util.Date</p><p>8.text<br>文本<br>适用于富文本、文章正文等<br>对应Java中的String</p><p>9.enum<br>枚举<br>适用于性别、订单状态等<br>对应Java中的String</p><p>10.blob<br>二进制<br>适用于小图片、小音频等。（不过更常用的做法是上传到服务器，在DB中存储url）<br>对应Java中的byte[]</p><p>11.bit数据类型是整型，其值只能是0、1或空值。<br>这种数据类型用于存储只有两种可能值的数据，如Yes 或No、True 或False 、On 或Off。<br>注意：很省空间的一种数据类型，如果能够满足需求应该尽量多用。</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld</title>
      <link href="/2023/03/12/1.hello-world/"/>
      <url>/2023/03/12/1.hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>Hello World Welcome To ObscureLine</p>]]></content>
      
      
      <categories>
          
          <category> HelloWorld </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HelloWorld </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
